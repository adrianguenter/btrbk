#!/usr/bin/dash
# TODO: ^^^^^^^ Revert to /bin/sh

export POSIXLY_CORRECT=1

set -eu # exit on error, error on unset
[ "${TRACE:=0}" -eq 1 ] && set -x # TRACE=1 btrbk-restore-raw ...

: "${TESTRUN:=0}" # TESTRUN=1 btrbk-restore-raw ...

: "${INPLACE:=0}" # INPLACE=1 btrbk-restore-raw ...

: "${BLOCKSIZE:=$((64 * 1024 * 1024))}" # BLOCKSIZE=$((1024 * 1024 * 1024)) btrbk-restore-raw ...
BLOCKSIZE=$(($BLOCKSIZE + 0))

# Newline character constant (for use in parameter substitution)
NL='
';
# IEC byte multiple constants
KiB=1024; MiB=$((1024 * KiB)); GiB=$((1024 * MiB)); TiB=$((1024 * GiB)); PiB=$((1024 * TiB))
# SI byte multiple constants
 KB=1000;  MB=$((1000 * KB));   GB=$((1000 * MB));   TB=$((1000 * GB));   PB=$((1000 * TB))

# Determine if a string is parseable as a signed integer
_test_parse_int() { ( [ $((${1#+} + 0)) = "${1#+}" ] ) 2>/dev/null; }

# Determine maximum number value and set INTMAX constant
# POSIX specifies only signed long C ints for arithmetic expansion $(())
if _test_parse_int '9223372036854775807'; then
  INTMAX=9223372036854775807 # SInt64
elif _test_parse_int '2147483647'; then
  INTMAX=2147483647 # SInt32
  _errecho "WARNING: This system only supports file sizes <2GB"
else
  _ERR "This system doesn't seem to support signed integers >= 32 bits"
fi


# Add two positive numbers without overflows
_safe_add() {
  [ -n "${1#-*}" ] || _ERR "_safe_add: Operand 1 must be positive"
  [ -n "${2#-*}" ] || _ERR "_safe_add: Operand 2 must be positive"
  # TODO allow for negative (or mixed) operands
  # * If both negative ensure result is not > 0
  # * If mixed ensure result is not > than the positive one
  # Validate operands using test (triggers error on overflow)
  _test_parse_int "$1" || _ERR "_safe_add: Failed parsing operand 1 (overflow?): ${1}"
  _test_parse_int "$2" || _ERR "_safe_add: Failed parsing operand 2 (overflow?): ${2}"
  # Validate result
  [ $(($1 + $2 < 0)) -eq 1 ] && _ERR "_safe_add: Overflow in (${1} + ${2})"
  printf '%d' $(($1 + $2))
}

# "_echo [$string...]" - println to STDOUT, var prefix: "__echo_"
_echo() { [ $# -le 1 ] && { printf '%s\n' "${1-}"; return; }
  __echo_s=; for __echo_i in "$@"; do __echo_s="$__echo_s $__echo_i"; done; printf '%s\n' "$__echo_s"; unset __echo_s __echo_i; }

# "see: _echo" - println to STDERR
_errecho() { >&2 _echo "$@"; }

# "" - do not use, overrides system echo to enforce _echo usage
echo() { _ERR "Use _echo instead of echo"; }

# "_str_contains $haystack $needle" - returns 0 if $needle is contained in $haystack, ex: if _str_contains abc b; ...
_str_contains() { [ -z "$2" ] || [ -n "$1" ] && [ -z "${1##*"${2}"*}" ]; }

# "_trap $callback $signal..." - passes $signal as argument 1 to $callback, var prefix: "__trap_", ex: _trap 'echo $1' INT TERM EXIT
_trap() { __trap_cb="$1"; shift; for __trap_s in "$@" ; do trap "$__trap_cb $__trap_s" "$__trap_s"; done; unset __trap_cb __trap_s; }

# "_safe_dquoteval $value" - prepends backslash, backtick/backquote, dollar-sign, and double-quote in $value with \ and wraps the result in double-quotes for use in eval'd double-quoted strings, ex: eval "echo $(_safe_dquoteval "\$(date)")"
# WARNING: Do NOT wrap the output of this function in escaped double-quotes at the call site! WRONG: eval "echo \"$(_safe_dquoteval "\$(date)")\""
# NOTE: != 0 is intentional to ensure string comparison
_safe_dquoteval() { [ "${2-1}" = 0 ]||printf \"; printf %s "$1" | sed 's/[\\`$"]/\\&/g'; [ "${2-1}" = 0 ]||printf \"; }

# "_safe_eval_setvar $name $value" - validates $name and sanitizes $value using _safe_dquoteval before setting the variable using eval
_safe_eval_setvar() {
  { printf '%s' "$1" | grep -q '[^A-Za-z0-9_]'; } && return 1; eval "$1=$(_safe_dquoteval "$2")"; }

# "_require_bin $command [$pkgname]" - enforces the existence of an executable name in $PATH, var prefix: "__reqbin_", ex: _require_bin btrfs btrfs-progs
_require_bin() { __reqbin_p="$(command -v "$1" ||:)"
  # Ensure that $__reqbin_p is both absolute (starts with "/") and also ends in "/<command_name>" ("/binfile" matches)
  [ "${__reqbin_p%${__reqbin_p#?}}${__reqbin_p#${__reqbin_p%/${1}}}" = "//${1}" ] || _DEPENDENCY_ERR "$1" "$2"; unset __reqbin_p; }

# "_add_cleanup_paths $glob..." - adds paths (globs) to unlink during _CLEANUP, var prefix: "__clnpth_"
_add_cleanup_paths() {
  : "${__file_path_sep:="$(printf '\001')"}"
  for __clnpth_p in "$@"; do
    _str_contains "$__clnpth_p" "$__file_path_sep" && _ERR 'Path contains list separator char'
    __cleanup_paths="${__cleanup_paths-}${__cleanup_paths:+${__file_path_sep}}${__clnpth_p}"
  done; unset __clnpth_p
}

# "_load_info_file $file" - loads K/V pairs from $file into variables named __INFOFILE__${KEY}, var prefix: "__ldinfo_"
_load_info_file() {
  if [ "${1#${1%.info}}"_ != '.info'_ ]; then
    _errecho "WARNING: Expected info (sidecar) file to have an extension of \".info\": ${1}"
  fi
  {
    read -r __ldinfo_v
    case "$__ldinfo_v" in
      '#btrbk-'*) ;;
      *) _ERR "Info (sidecar) file does not start with a #btrbk-v\${VERSION} line: ${1}"
    esac
    while IFS="=" read -r __ldinfo_k __ldinfo_v; do
      case "$__ldinfo_k" in
        '') ;;
        '#'*) ;;
        *) _safe_eval_setvar "__INFOFILE__${__ldinfo_k}" "$__ldinfo_v" || _ERR "Info (sidecar) file has an invalid key: ${1}"
      esac
    done
  } < "$1"; unset __ldinfo_k __ldinfo_v
}

# Outputs a normalized version of a list ("a,f,b,,,c,d,,b,,e,f" => "a,f,b,c,d,e")
_dd_listnorm() { printf '%s' "$1" | awk 'BEGIN{RS=ORS=","} {if($1!=""&&!seen[$1]++){ORS=y;print s;y=",";s=$1}} END{ORS="";print s}'; }
_dd_listadd() { _dd_listhas "$1" "$2" && printf '%s' "$1" || printf '%s%s' "${1:+"${1},"}" "$2"; }
# WARNING: List must be normalized (`list="$(_dd_listnorm "$list")"`) before using _dd_listrem! (Subshell for brevity)
_dd_listrem() { ! _dd_listhas "$1" "$2" && printf '%s' "$1" || ( a="${1#*"${2}"},${1%"${2}"*}"; a="${a##,}"; printf '%s' "${a%%,}" ); }
# Like performing _str_contains but checks comma boundaries to ensure that the search value isn't a substring of another value
_dd_listhas() { [ -n "$1" ] && [ -n "$2" ] && { [ "$1" = "$2" ] || [ -z "${1##*"${2},"*}" ] || [ -z "${1##*",${2}"*}" ]; }; }
_dd() {
  # dd always outputs full obs blocks (it will block until it can do so), thus we should leverage that
  # to determine the amount of bytes read by dd's status output of records (we NEVER want a partial!)
  # Partial or zero read can only happen once, then we're done reading (as dd will block until it has an output block to write)
  # This function should just do The Right Thing under any circumstance
  # * if dd doesn't support fullblock we need to synchronize the input of the main dd (dd obs=$size | dd bs=$size ...)
  #  See: https://unix.stackexchange.com/questions/32988/why-does-dd-from-dev-random-give-different-file-sizes/192092#192092

  # NOTE: iflag=fullblock is automatically enabled if count= and/or skip= are used

  # Default input and output block size values (POSIX >= 512, Linux = >=4096)

  # set -x # TODO REMOVE ==========================================================================

  __dd_ibs=4096
  __dd_obs=4096

  __dd_emu_fullblock=0
  __dd_emu_skipbytes=0
  __dd_emu_countbytes=0
  __dd_emu_seekbytes=0
  # Parse args
  for __dd_a in "$@"; do
    case "$__dd_a" in
      if=*)       __dd_if="${__dd_a#if=}" ;;
      of=*)       __dd_of="${__dd_a#of=}" ;;
      ibs=*)     __dd_ibs="${__dd_a#ibs=}" ;;
      obs=*)     __dd_obs="${__dd_a#obs=}" ;;
      bs=*)       __dd_bs="${__dd_a#bs=}" ;;
      count=*) __dd_count="${__dd_a#count=}" ;;
      skip=*)   __dd_skip="${__dd_a#skip=}" ;;
      seek=*)   __dd_seek="${__dd_a#seek=}" ;;
      conv=*)   __dd_conv="$(_dd_listadd "${__dd_conv-}"  "${__dd_a#conv=}")" ;;
      iflag=*) __dd_iflag="$(_dd_listadd "${__dd_iflag-}" "${__dd_a#iflag=}")" ;;
      oflag=*) __dd_oflag="$(_dd_listadd "${__dd_oflag-}" "${__dd_a#oflag=}")" ;;
      status=*) _ERR "Setting status= value is not supported (use pv instead)" ;;
      *) _ERR "Unsupported dd operand: $__dd_a"
    esac
  done

  # Validate size options (NOTE: all must be byte|count values, no suffixes!)
  if [ -n "${__dd_ibs:+set}" ]; then _test_parse_int "$__dd_ibs" || _ERR "Invalid ibs value: $__dd_ibs"; fi
  if [ -n "${__dd_obs:+set}" ]; then _test_parse_int "$__dd_obs" || _ERR "Invalid obs value: $__dd_obs"; fi
  if [ -n "${__dd_bs:+set}" ]; then
    _test_parse_int "$__dd_bs" || _ERR "Invalid bs value: $__dd_bs"
    __dd_ibs=$__dd_bs # Are we sure we want to override these here?
    __dd_obs=$__dd_bs # Probably, because then we can be explicit
  fi
  if [ -n "${__dd_count:+set}" ]; then
    _test_parse_int "$__dd_count" || _ERR "Invalid count value: $__dd_count"
    __dd_iflag="$(_dd_listadd "${__dd_iflag-}" fullblock)" # Force fullblock for count=
  fi
  if [ -n "${__dd_skip:+set}" ]; then
    _test_parse_int "$__dd_skip" || _ERR "Invalid skip value: $__dd_skip"
    __dd_iflag="$(_dd_listadd "${__dd_iflag-}" fullblock)" # Force fullblock for skip=
  fi
  if [ -n "${__dd_seek:+set}" ]; then _test_parse_int "$__dd_seek" || _ERR "Invalid seek value: $__dd_seek"; fi

  # Normalize list options (item[,...]) to remove duplicates and null items (,,[,...])
  if [ -n "${__dd_conv:+isset}" ]; then
     __dd_conv="$(_dd_listnorm "$__dd_conv")"
  fi
  if [ -n "${__dd_iflag:+isset}" ]; then
    __dd_iflag="$(_dd_listnorm "$__dd_iflag")"
    if { _dd_listhas "$__dd_iflag" fullblock && [ $DD_IFLAG_FULLBLOCK -ne 1 ]; }; then
      __dd_iflag="$(_dd_listrem "$__dd_iflag" fullblock)"
      __dd_emu_fullblock=1
    fi
    if { _dd_listhas "$__dd_iflag" count_bytes && [ $DD_IFLAG_COUNTBYTES -ne 1 ]; }; then
      __dd_iflag="$(_dd_listrem "$__dd_iflag" count_bytes)"
      # Only enable emulation if actually needed (count is set and > 0)
      [ ${__dd_count:-0} -gt 0 ] && __dd_emu_countbytes=1
    fi
    if { _dd_listhas "$__dd_iflag" skip_bytes && [ $DD_IFLAG_SKIPBYTES -ne 1 ]; }; then
      __dd_iflag="$(_dd_listrem "$__dd_iflag" skip_bytes)"
      # Only enable emulation if actually needed (skip is set and > 0)
      [ ${__dd_skip:-0} -gt 0 ] && __dd_emu_skipbytes=1
    fi
  fi
  if [ -n "${__dd_oflag:+isset}" ]; then
     __dd_oflag="$(_dd_listnorm "$__dd_oflag")"
    if { _dd_listhas "$__dd_oflag" seek_bytes && [ $DD_OFLAG_SEEKBYTES -ne 1 ]; }; then
      __dd_oflag="$(_dd_listrem "$__dd_oflag" seek_bytes)"
      # Only enable emulation if actually needed (seek is set and > 0)
      [ ${__dd_seek:-0} -gt 0 ] && __dd_emu_seekbytes=1
    fi
  fi
_errecho "final iflag=$__dd_iflag"
  # skip_bytes/count_bytes emulation
  # 1) skip=1 count=0 with ibs=$((skip_bytes % ibs)) (if > 0)
  # 2) skip=$((skip_bytes / $ibs)) count=$((count_bytes / $ibs))
  # 3) skip=0 count=1 with ibs=$((count_bytes % ibs)) (if > 0)
  # 4) ...? seek? how to? can we maybe just set obs=seek_bytes and seek=1 ???
  #    We can't really call dd more than once to seek if working on an of=$file
  #    Seek emulation seems impractical as obs can't be set to an arbitrarily large size
  #    The only way I can think of is to chop up the seek_bytes value into obs sized chunks; first reading from the last
  #    chunk through the remainder, piping that into the seeking/end dd while it seeks the chunks then writes that, then continues
  #    writing from the earlier pipe dd1 | { dd ibs=$obs if=$of skip=$seek count= | dd3 obs= of=$of seek= }
  #    TOO COMPLICATED FOR NOW, we should just implement count_bytes and skip_bytes at any rate

  # TODO: Wrap function in subshell?

  # if=/dev/random bs=4 skip_bytes=14 count_bytes=17 seek_bytes=15
  # for iflag=fullblock we might need to call this function again (make sure it's converted to subshell first!)
  #
  # seek_bytes emulation:
  # seek=15 bs=4
  # { tail -c $((15/4=3)) $of                            # seek to arbitrary pos
  #     | dd obs=$((15%4+1=4))                           # force fullbock if needed (no iflag=fullblock)
  #     | dd ibs=$((15%4+1=4)) obs=$((15%4=3)) count=1   # now read remainder before real input
  #   ; {fullblock |} dd if=$if ...                      # real input (skip/count here)
  # } | dd ibs=$bs obs=$bs seek=$((15/4=3)) of=$of       # output
  #
# FULLBLOCK EMU:
#      { __dd_stats="$( [ $TRACE -eq 1 ] && set -x; \
#          dd status=none ibs="$((${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}} + 1))" obs="${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}}" \
#            ${__dd_if:+if="$__dd_if"} ${__dd_iflag:+iflag="$__dd_iflag"} \
#          | 2>&1 1>&3 dd ibs="${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}}" obs="${__dd_bs:-${__dd_obs:-${__dd_def_bs}}}" \
#            ${__dd_count:+count="$__dd_count"} ${__dd_skip:+skip="$__dd_skip"} ${__dd_seek:+seek="$__dd_seek"} \
#            ${__dd_of:+of="$__dd_of"} ${__dd_oflag:+oflag="$__dd_oflag"} ${__dd_bufd_conv:+conv="$__dd_bufd_conv"} \
#        )";
#      } 3>&1

  # When fullblock emulation is on we always have a primary source dd which gets if= and such
  # Otherwise if= and such are set to each read dd with iflag=fullbock
  #

  # If no emulation is necessary at all we should use just one dd command

  __cmd=
  __cmd_end=

  if [ $__dd_emu_fullblock -eq 1 ]; then
      __dd_a=
      if [ -n "${__dd_conv:+set}" ]; then
        # Remove conv= options that apply to the output blocks and file, then add them to a seperate list for second dd
        for __dd_a in excl nocreat notrunc fdatasync fsync; do
          _dd_listhas "$__dd_conv" $__dd_a || continue
          __dd_conv="$(_dd_listrem "$__dd_conv" $__dd_a)"
          __dd_bufd_conv="$(_dd_listadd "${__dd_bufd_conv-}" $__dd_a)"
        done
      fi
    # Write full (optionally converted) $ibs records from input
    # This can be continued by a simple read with either count or skip
    # If we need count_bytes or skip_bytes emulation we need to read from fullblock dd in braces

    # TODO: Allow user to set this somehow
    __dd_emu_fullblock_ibs=$(($__dd_ibs / 2 ))
    [ $__dd_emu_fullblock_ibs -lt 1 ] && __dd_emu_fullblock_ibs=1

    __cmd="dd status=none ibs=${__dd_emu_fullblock_ibs}${__dd_iflag:+ iflag="$(_safe_dquoteval "$__dd_iflag")"}"
    __cmd="${__cmd}${__dd_if:+ if="$(_safe_dquoteval "$__dd_if")"}"
    __cmd="${__cmd}${__dd_cbs:+ cbs="$__dd_cbs"}${__dd_conv:+ conv="$(_safe_dquoteval "$__dd_conv")"}"
    __cmd="${__cmd} obs=${__dd_ibs} | "

    unset __dd_if

  # Can we unset __dd_iflag __dd_if __dd_cbs __dd_conv now or do we need iflag for other parts?
  fi
    __cmd="$__cmd"

  # skip_bytes emulation:
  # skip=14 ibs=4
  # {fullblock_dd |} { $((14%4>0)) && dd ibs=$((14%4=2)) skip=1 count=0; dd ibs=$bs obs=$bs skip=$((14/4=3)) }
  # count & skip
  # {fullblock_dd |} { $((14%4>0)) && dd ibs=$((14%4=2)) skip=1 count=0;
  #   dd ibs=$bs obs=$bs skip=$((14/4=3)) count=$((17/4=4));
  #   $((17%4>0)) && dd ibs=$((17%4=1)) count=1; } <$if

  # If skip_bytes|count_bytes and skip or count need more than one read we need another piped dd for output

  # $__dd_skip is > 0 if $__dd_emu_skipbytes is enabled
  # Skip remainder first
  __cmd_skip=
  if [ $__dd_emu_skipbytes -eq 1 ]; then
    if [ $(($__dd_skip % $__dd_ibs)) -gt 0 ]; then
      __cmd_skip="dd ibs=$(($__dd_skip % $__dd_ibs))${__dd_iflag:+ iflag="$(_safe_dquoteval "$__dd_iflag")"} skip=1 count=0; "
    fi
    __dd_skip=$(($__dd_skip / $__dd_ibs))
  fi

  __cmd_count=
  # $__dd_count is > 0 if $__dd_emu_countbytes is enabled
  if [ $__dd_emu_countbytes -eq 1 ]; then
    if [ $(($__dd_count % $__dd_ibs)) -gt 0 ]; then
      __cmd_count="; dd ibs=$(($__dd_count % $__dd_ibs))${__dd_iflag:+ iflag="$(_safe_dquoteval "$__dd_iflag")"} skip=0 count=1"
      __cmd_count="${__cmd_count}${__dd_cbs:+ cbs="$__dd_cbs"}${__dd_bufd_conv:+ conv="$(_safe_dquoteval "$__dd_bufd_conv")"}"
    fi
    __dd_count=$(($__dd_count / $__dd_ibs))
  fi

  if [ -n "$__cmd_skip$__cmd_count" ]; then
    __cmd="${__cmd}{ "
    __cmd_end="; }${__dd_if:+ <"$(_safe_dquoteval "$__dd_if")"} | output dd"
    unset __dd_if # Previously potentially unset by fullblock emu
  fi

# { dd bs=1 iflag=fullblock,count_bytes oflag=seek_bytes skip=0 count=1 seek=400; dd bs=1 iflag=fullblock,count_bytes oflag=seek_bytes skip=0 count=1 seek=200; } </dev/zero >test
# WORKS!

  # Write to output
  __cmd="${__cmd}${__cmd_skip}dd ibs=${__dd_ibs}${__dd_iflag:+ iflag="$(_safe_dquoteval "$__dd_iflag")"}"
  __cmd="${__cmd}${__dd_if:+ if="$(_safe_dquoteval "$__dd_if")"}"
  __cmd="${__cmd}${__dd_cbs:+ cbs="$__dd_cbs"}${__dd_bufd_conv:+ conv="$(_safe_dquoteval "$__dd_bufd_conv")"}"
  __cmd="${__cmd}${__dd_skip:+ skip="$__dd_skip"}${__dd_count:+ count="$__dd_count"}${__dd_seek:+ seek="$__dd_seek"}"
  __cmd="${__cmd} obs=${__dd_obs}${__dd_oflag:+ oflag="$(_safe_dquoteval "$__dd_oflag")"}${__dd_of:+ of="$(_safe_dquoteval "$__dd_of")"}"

  __cmd="${__cmd}${__cmd_count}${__cmd_end}"

  # TODO Check if we had more than one command above and write trailing } here


_errecho "$ $__cmd"
exit
#  fi

  # skip_bytes emulation:
  # skip=14 ibs=4
  # {fullblock_dd |} { $((14%4>0)) && dd ibs=$((14%4=2)) skip=1 count=0; dd ibs=$bs obs=$bs skip=$((14/4=3)) }
  #
  # count_bytes emulation
  # count=17 ibs=4
  # {fullblock_dd |} { dd ibs=$bs obs=$bs count=$((17/4=4)); $((17%4>0)) && dd ibs=$((17%4=1)) count=1; } <$if
  #
  # How to mix them?
  # count & skip
  # {fullblock_dd |} { $((14%4>0)) && dd ibs=$((14%4=2)) skip=1 count=0;
  #   dd ibs=$bs obs=$bs skip=$((14/4=3)) count=$((17/4=4));
  #   $((17%4>0)) && dd ibs=$((17%4=1)) count=1; } <$if
  #
  # Maybe we should assign different fds to each step and background them then wait for pids?
  # Might make implementation easier and remove need for eval or named pipes
  #
  # skip_bytes/count_bytes emulation
  # 1) skip=1 count=0 with ibs=$((skip_bytes % ibs)) (if > 0)
  # 2) skip=$((skip_bytes / $ibs)) count=$((count_bytes / $ibs))
  # 3) skip=0 count=1 with ibs=$((count_bytes % ibs)) (if > 0)

  # skip bytes emu
  ___dd_cmd=
  # {fullblock_dd |} { $((14%4>0)) && dd ibs=$((14%4=2)) skip=1 count=0; dd ibs=$bs obs=$bs skip=$((14/4=3)) } <$if
  if [ $__dd_emu_skipbytes -eq 1 ]; then
    #if [ $(($ibs / skip)) -eq 0...
    __dd_incmd=
  fi

  if [ $(($__dd_emu_countbytes + $__dd_emu_skipbytes + $__dd_emu_seekbytes)) -gt 0 ]; then
    _errecho "WARNING: Emulating GNU dd iflag=(count|skip)_bytes/oflag=seek_bytes"


    while : ; do
      if [ $__dd_emu_fullblock -eq 1 ]; then
        _errecho "WARNING: Emulating GNU dd iflag=fullblock"
        # Notes about dd's buffering/blocking behavior:
        # * For GNU dd bs= always takes precedence over ibs= and obs=; for BusyBox (and others?) it's positional
        #   We should adhere to the GNU standard as it's easier to implement and this func is essentially a shim for GNU dd
        # * Unless bs= or obs= is set dd will write what its read call returned (up to ibs bytes)
        # * If ibs > obs dd will write up to ibs bytes per read regardless of obs! (can this be modified with a conv= option?)
        # * Because count= and skip= *limit INPUT BLOCKS* which can ALWAYS be PARTIAL READS/SKIPS the only way to ensure
      #   an arbitrary number of bytes/ibs-sized blocks are skipped/written out is to use iflag=fullblock or buffer dd with another
      #   by matching obs of first to ibs of second (as first dd will block until either a full output block (of obs= or bs= size)
      #   is ready to write, or EOF from input)
      # We need to place a buffer of a known size between the input and output using another instance of dd
      # Never set bs= on the first dd!
      # cbs=, *conv=, skip=, count=, ibs=, if=, and iflag= apply to first
      # *conv=, seek=, obs=, of=, and oflag= apply to second

      __dd_a=
      if [ -n "${__dd_conv:+isset}" ]; then
        # Remove conv= options that apply to the output blocks and file, then add them to a seperate list for second dd
        for __dd_a in excl nocreat notrunc fdatasync fsync; do
          _dd_listhas "$__dd_conv" $__dd_a || continue
          __dd_conv="$(_dd_listrem "$__dd_conv" $__dd_a)"
          __dd_bufd_conv="$(_dd_listadd "${__dd_bufd_conv-}" $__dd_a)"
        done
      fi
      __dd_def_bs=512
      # NOTE: BusyBox dd will write a partial output block if ibs is equal to obs, therefore we set first dd ibs=obs+1
      { __dd_stats="$( [ $TRACE -eq 1 ] && set -x; \
          dd status=none ibs="$((${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}} + 1))" obs="${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}}" \
            ${__dd_cbs:+cbs="$__dd_cbs"} ${__dd_conv:+conv="$__dd_conv"} \
            ${__dd_if:+if="$__dd_if"} ${__dd_iflag:+iflag="$__dd_iflag"} \
          | 2>&1 1>&3 dd ibs="${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}}" obs="${__dd_bs:-${__dd_obs:-${__dd_def_bs}}}" \
            ${__dd_count:+count="$__dd_count"} ${__dd_skip:+skip="$__dd_skip"} ${__dd_seek:+seek="$__dd_seek"} \
            ${__dd_of:+of="$__dd_of"} ${__dd_oflag:+oflag="$__dd_oflag"} ${__dd_bufd_conv:+conv="$__dd_bufd_conv"} \
        )";
      } 3>&1
      _errecho ">>>$__dd_stats"
      exit

      ## TODO Get all of stderr from dd (remove grep) and case through each line with globs, this would make for more
      ## resilient parsing as well as allowing for error checking
      #[ -n "$__dd_stats" ] || _ERR 'Failed to parse dd status output'
      #__dd_stats_in="${__dd_stats%% records in"$NL"*}"
      #__dd_stats_out="${__dd_stats##"${__dd_stats%%"$NL"*}$NL"}"
      #__dd_stats_out="${__dd_stats_out% records out}"
      #[ ${#__dd_stats_in} -eq 3 ]  && [ -z "${__dd_stats_in#?+?}" ]  || _ERR 'Failed to parse dd records in'
      #[ ${#__dd_stats_out} -eq 3 ] && [ -z "${__dd_stats_out#?+?}" ] || _ERR 'Failed to parse dd records out'
      #__dd_stats_out_whole="${__dd_stats_out%+*}"
      #__dd_stats_out_partial="${__dd_stats_out#*+}"
      #__dd_stats_in_whole="${__dd_stats_out%+*}"
      #__dd_stats_in_partial="${__dd_stats_in#*+}"
      #_errecho "IN:  $(($__dd_stats_in_whole * $__dd_bs)) + (${__dd_stats_in_partial} * ?)"
      #_errecho "OUT: $(($__dd_stats_out_whole * $__dd_bs)) + (${__dd_stats_out_partial} * ?)"


      break # TODO REMOVE --------------------------------********************************************
   fi

    done
  else
    { __dd_stats="$( [ $TRACE -eq 0 ] && set -x; \
        2>&1 1>&3 dd ${__dd_bs:+bs="$__dd_bs"} ${__dd_cbs:+cbs="$__dd_cbs"} ${__dd_conv:+conv="$__dd_conv"} \
          ${__dd_count:+count="$__dd_count"} ${__dd_skip:+skip="$__dd_skip"} ${__dd_seek:+seek="$__dd_seek"} \
          ${__dd_ibs:+ibs="$__dd_ibs"} ${__dd_if:+if="$__dd_if"} ${__dd_iflag:+iflag="$__dd_iflag"} \
          ${__dd_ibs:+obs="$__dd_obs"} ${__dd_of:+of="$__dd_of"} ${__dd_oflag:+oflag="$__dd_oflag"} \
      )";
    } 3>&1
  fi
}

_test_source() {
  # Verifies the beginning and end of the stream
  __tstsrc_total_bytes=$(($2 + 0))
  __SENDSTREAM__subvolname=
  _reconstruct_source "$1" "$2" "$3" $((1024 * 1024)) 0 | {
    # NOTE: The send stream stores number values as little-endian (0x3c, 0x00 is decimal value 60, not 15360)
    # Thus we can manipulate them as number strings using od and and other tools, as they will terminate reading
    # on the first 0x00 (null) byte
    # See: https://btrfs.wiki.kernel.org/index.php/Design_notes_on_Send/Receive

    # send stream header: 17 bytes
    dd status=none bs=1 count=13 | grep -q ^btrfs-stream         || _ERR "bad magic value" # magic "btrfs-stream\0"
    dd status=none bs=1 count=4  | grep -q ^"$(printf '\001')"\$ || _ERR "stream version != 0x01" # stream version

    # send command header: 10 bytes
    dd status=none bs=1 skip=4 count=0 # command size; unneeded as the only info we want is in TLV1
    # Expect and validate a "Send subvolume or snapshot" command (0x01 or 0x02)
    __tstsrc_cmdtype=$(($(dd status=none bs=1 count=2 | od -An -vtu2) + 0)) # command type
    [ $__tstsrc_cmdtype -eq 1 ] || [ $__tstsrc_cmdtype -eq 2 ] || _ERR "command type != 0x01|0x02 "
    # NOTE: We don't perform a CRC32 check here as we have no easy way of getting the bytes to checksum (they contain 0x0 anyway!)
    dd status=none bs=1 skip=4 count=0 # CRC32

    # send TLV1 (name) header: 4 bytes
    dd status=none bs=1 count=2 | grep -q ^"$(printf '\017')"\$ || _ERR "TLV1 type != 0x0f"
    __tstsrc_subvolname_size=$(($(dd status=none bs=1 count=2 | od -An -vtu2) + 0))

    # send TLV1 (name) payload: $subvolname_size bytes
    __SENDSTREAM__subvolname="$(dd status=none bs=1 count=$__tstsrc_subvolname_size)"

    # skip to end - 6 bytes (send end command)
    # TODO? Skip this check altogether and WARN if $__total_bytes is over $4 and fullblock or skip_bytes is unavailable
    dd status=none bs=1M iflag=fullblock,skip_bytes skip=$(($__tstsrc_total_bytes - 6 - $__tstsrc_subvolname_size - 31)) count=0
    dd status=none bs=1 count=2 | grep -q ^"$(printf '\025')"\$ || _ERR "send end fail"
    dd status=none bs=1 count=4 | grep -q ^"$(printf '\120\154\311\235')"\$ || _ERR "send end fail"
  }
  unset __tstsrc_total_bytes __tstsrc_subvolname_size __tstsrc_cmdtype
}

_reconstruct_source() {
  __source_list="$1"
  __total_bytes=$(($2 + 0))
  __toolchain="${3-}"
  __block_size=$((${4:-BLOCKSIZE} + 0))
  __source_destroy="${5:-0}"

  # TODO Does this belong here or below in main? (Prob. the latter)
  if [ "$INPLACE" -eq 1 ]; then
    # TODO ASK FOR CONFIRMATION!
    _errecho "WARNING: Disabling SIGINT (Ctrl-c) for destructive operation!"
    trap - INT
  fi

  __read_bytes=0
  __remaining_bytes="$__total_bytes"
  for __f in $__source_list; do
    __f_size="$(stat -c%s "$__f")"
    __f_remaining_bytes="$__f_size"
    __f_pos=0
    __dd_bytes="$__block_size"
    while : ; do
      [ $__remaining_bytes -gt 0 ] || break
      [ $__f_remaining_bytes -gt 0 ] || break

      [ $__dd_bytes -le $__remaining_bytes ] || __dd_bytes=$__remaining_bytes
      [ $__dd_bytes -le $__f_remaining_bytes ] || __dd_bytes=$__f_remaining_bytes


      # TODO? Use dd without unportable options and WARN if fullblock, skip_bytes, or count_bytes is unavailable
      # This would require parsing dd's status output to determine the number of bytes read
      # _errecho "Read from: $__rpos"
      dd status=none if="$__f" bs=1M skip="$__f_pos" count="$__dd_bytes" iflag=fullblock,skip_bytes,count_bytes

      __f_pos=$(($__f_pos + $__dd_bytes))
      __f_remaining_bytes=$(($__f_remaining_bytes - $__dd_bytes))
      __read_bytes=$(($__read_bytes + $__dd_bytes))
      __remaining_bytes=$(($__remaining_bytes - $__dd_bytes))

      # TODO fallocate
      # _errecho "fallocate"
      #fallocate --keep-size --punch-hole --offset $readpos --length $readsize $infile >&2 &
    done
    #_errecho "FILE DONE: ${__f}"
  done
  #_errecho "READ DONE"
}

_USAGE() {
  >&2 printf \
'usage: [TESTRUN=1] [BLOCKSIZE=<bytes>] [INPLACE=1] [TRACE=1] %s <info-file> <target-subvol>

Environment variables:

TESTRUN=1  Perform a test run of BLOCKSIZE bytes (disables INPLACE)

BLOCKSIZE=<bytes>  Set the amount of bytes read (and truncated, if INPLACE) at a time
                   Note that shell arithmetic $((...)) can be used to calculate values, for example
                   BLOCKSIZE=$((64 * 1024 * 1024)) sets the value to 67108864 (64MiB), the default

INPLACE=1  Truncate the head of the source raw backup file (fallocate --punch-hole) as its read;
           a mandatory test run will automatically be performed and must complete successfully
           === WARNING ===
           THIS OPTION DESTROYS THE RAW BACKUP SOURCE FILE -- ENSURE THAT YOU HAVE ANOTHER COPY
           OF THE SNAPSHOT OR CAN AFFORD TO LOSE THE DATA BEFORE ENABLING THIS OPTION!
           If the restore operation fails for any reason the file will be PERMANENTLY CORRUPTED,
           so only use if absolutely necessary; e.g. the backup file and target are on the same
           btrfs filesystem and the space used by the file is needed to restore the subvolume

TRACE=1    Enable shell trace output

' "$(basename "${0}")"
  exit 1
}

_ERR() {
  _errecho "ERROR: ${1}"
  [ "${2:-0}" -eq 1 ] && { _errecho; USAGE; }
  exit "${3:-1}"
}

_DEPENDENCY_ERR() {
  >&2 printf 'ERROR: "%s" not found in $PATH%s\n' "$1" "${2:+"; is the \"${2}\" package (or equivalent) installed?"}"
  exit 9
}

_CLEANUP() ( # VAR PREFIX: __clnup_
  set +e
  __clnup_l="${__clnup_paths-}"; while [ "$__clnup_l" != "${__clnup_l2-}" ]; do
    __clnup_l="${__clnup_l2:-${__clnup_l}}"
    __clnup_l2="${__clnup_l%${__file_path_sep}*}"
    __clnup_v="${__clnup_l#${__clnup_l2}${__file_path_sep}}"
    rm "$__clnup_v"
  done; unset __clnup_l __clnup_l2 __clnup_v
)

_SHUTDOWN() {
  [ "${__shutdown_bypass-0}" -eq 1 ] && return
  __shutdown_bypass=1
  case "${1-}" in
    INT|TERM) trap - INT TERM;;
    EXIT) : ;;
    *) _ERR "Invalid shutdown signal: $1" 0 127
  esac
  _echo "==> SHUTDOWN: $1"
  _CLEANUP
}

_MAIN() {
  _trap _SHUTDOWN INT TERM EXIT

  # Required dependencies
  _require_bin awk      awk
  _require_bin grep     grep
  _require_bin sed      sed # TODO Replace all sed with awk
  _require_bin btrfs    btrfs-progs
  _require_bin basename coreutils
  _require_bin dirname  coreutils
  _require_bin dd       coreutils
  _require_bin od       coreutils
  _require_bin readlink coreutils
  _require_bin stat     coreutils

  # Feature-test dd
  DD_IFLAG_FULLBLOCK=0
  DD_IFLAG_SKIPBYTES=0
  DD_IFLAG_COUNTBYTES=0
  DD_OFLAG_SEEKBYTES=0
  dd_helptxt="$(dd --help 2>&1)" \
  || dd_helptxt="$(dd -h 2>&1)" \
  || _ERR "Failed to parse help text for dd"
  _str_contains "$dd_helptxt" fullblock   && DD_IFLAG_FULLBLOCK=1
  _str_contains "$dd_helptxt" skip_bytes  && DD_IFLAG_SKIPBYTES=1
  _str_contains "$dd_helptxt" count_bytes && DD_IFLAG_COUNTBYTES=1
  _str_contains "$dd_helptxt" seek_bytes  && DD_OFLAG_SEEKBYTES=1

  if [ "$INPLACE" -eq 1 ]; then
    _require_bin fallocate  util-linux
    _require_bin findmnt    util-linux

    # Feature-test fallocate
    falloc_punch_hole=
    falloc_helptxt="$(fallocate --help 2>&1)" \
    || falloc_helptxt="$(fallocate -h 2>&1)" \
    || _ERR "Failed to parse help text for fallocate"
    _str_contains "$falloc_helptxt" --punch-hole && falloc_punch_hole=' --punch-hole'

    # TODO Feature-test findmnt
  fi
total=$((1024 * 1024 * 1024 + 124283))
#dd status=none ibs=3 obs=7 if=/dev/random
DD_BLOCKFACTOR=1
# Full emu
DD_IFLAG_FULLBLOCK=${FULLBLK:-1}
DD_IFLAG_SKIPBYTES=${SKIP:-1}
DD_IFLAG_COUNTBYTES=${COUNT:-1}
DD_OFLAG_SEEKBYTES=${SEEK:-1}
_dd "$@" | pv -bn >/dev/null
exit

  # Script arguments
  source_info="${1-}"
  target="${2-}"

  # Source check
  if [ -z "$source_info" ]; then
    _ERR "Info (sidecar) file was not specified" 1
  elif ! [ -r "$source_info" ]; then
    _ERR "Info (sidecar) file doesn't exist or isn't readable: ${source_info}"
  fi

  source_dir="$(dirname "$(readlink -f "$source_info")")"
  source_info="${source_dir}/${source_info##*/}" # Canonicalize
  _load_info_file "$source_info"
  source_name="${__INFOFILE__FILE##*/}"
  subvol_name="${source_name%.btrfs*}"
  source="${source_dir}/${source_name}"

  if [ "${__INFOFILE__INCOMPLETE-0}" -eq 1 ]; then
    _ERR "Raw backup file is marked incomplete"
  fi

  if [ -n "${__INFOFILE__split+x}" ]; then
    source_glob="${source}.split_*"
  fi

  file_list=${source_glob:-$source}

  # Source sanity checks and preliminary info gathering
  toolchain=
  total_size=0
  for f in $file_list; do
    # Attempt capturing the filesystem name which houses the source file(s) to test for fallocate --punch-hole compat
    [ "$INPLACE" -eq 1 ] && "${source_fs:="$(findmnt -n -o FSTYPE --target "$f")"}"
    [ -r "$f" ] || _ERR "File doesn't exist or isn't readable: ${f}"
    fsize="$(stat -c%s "$f")"
    [ "$fsize" -gt 0 ] || _ERR "Source file appears empty (stat reported 0 bytes or errored): ${f}"
    total_size=$(($total_size + $fsize))
  done

  # $do_test_source && ...
  _test_source "$file_list" $total_size "$toolchain" || _ERR "Source test failed"

  _echo "NAME FROM STREAM: $__SENDSTREAM__subvolname" # Wait, what?
  [ -n "${__SENDSTREAM__subvolname-}" ] && subvolname="$__SENDSTREAM__subvolname"

  # Target sanity checks
  if [ -e "${target}/${subvol_name}" ]; then
    _ERR "Restore target exists, aborting: ${target}/${subvol_name}"
  fi

  set +e; target_info="$(btrfs subvolume show "$target")"; set -e
  [ $? -eq 0 ] || target_info=

  if [ -z "$target_info" ]; then
    _ERR "Restore target does not appear to be a btrfs subvolume (\"btrfs sub show '${target}'\" failed)"
  fi

  if printf '%s' "$target_info" | grep Flags: | grep -q readonly; then
    _ERR "Restore target appears to be readonly: ${target}"
  fi

  # Main
  _reconstruct_source "$file_list" $total_size "$toolchain" "$BLOCKSIZE" 0 \
  | btrfs receive -v "$target" #; _echo ">>>${?}" # "$target"

  exit 0
}

_MAIN "$@"

##### TODO
# * Build $toolchain pipeline string and eval it safely in _reconstruct_source
# * TESTRUN: make sure key can decrypt, or passphrase is correct, all utilities work, etc before INPLACE destructive read
# * ? unencrypt
#   - openssl
#     - keyfile
#     - kdf
#   - gpg
# * ? uncompress
#   - xz
#   - gzip
