#!/usr/bin/dash
# TODO: ^^^^^^^ Revert to /bin/sh

set -eu # exit on error, error on unset
[ "${TRACE:=0}" -eq 1 ] && set -x # TRACE=1 btrbk-restore-raw ...

: "${TESTRUN:=0}" # TESTRUN=1 btrbk-restore-raw ...

: "${INPLACE:=0}" # INPLACE=1 btrbk-restore-raw ...

: "${BLOCKSIZE:=$((64 * 1024 * 1024))}" # BLOCKSIZE=$((1024 * 1024 * 1024)) btrbk-restore-raw ...
BLOCKSIZE=$(($BLOCKSIZE + 0))

# Newline character (for use in parameter substitution)
NL='
';

# POSIX specifies only signed long C ints for arithmetic expansion $(())
if 2>/dev/null [ "$((9223372036854775807 + 0))" = '9223372036854775807' ]; then
  INTMAX=9223372036854775807 # SInt64
elif 2/dev/null [ "$((2147483647 + 0))" = '2147483647' ]; then
  INTMAX=2147483647 # SInt32
  _errecho "WARNING: This system only supports file sizes <2GB"
else
  _ERR "This system doesn't support signed integers >= 32 bits"
fi

_test_parse_num() { 2>/dev/null [ $(($1 + 0)) = "$1" ]; }

# Add two positive numbers without overflows
_safe_add() {
  [ -n "${1#-*}" ] || _ERR "_safe_add: Operand 1 must be positive"
  [ -n "${2#-*}" ] || _ERR "_safe_add: Operand 2 must be positive"
  # TODO allow for negative (or mixed) operands
  # * If both negative ensure result is not > 0
  # * If mixed ensure result is not > than the positive one
  # Validate operands using test (triggers error on overflow)
  _test_parse_num "$1" || _ERR "_safe_add: Failed parsing operand 1 (overflow?): ${1}"
  _test_parse_num "$2" || _ERR "_safe_add: Failed parsing operand 2 (overflow?): ${2}"
  # Validate result
  [ $(($1 + $2 < 0)) -eq 1 ] && _ERR "_safe_add: Overflow in (${1} + ${2})"
  printf '%d' $(($1 + $2))
}

# "_echo [$string...]" - println to STDOUT, var prefix: "__echo_"
_echo() { [ $# -le 1 ] && { printf '%s\n' "${1-}"; return; }
  __echo_s=; for __echo_i in "$@"; do __echo_s="$__echo_s $__echo_i"; done; printf '%s\n' "$__echo_s"; unset __echo_s __echo_i; }

# "see: _echo" - println to STDERR
_errecho() { >&2 _echo "$@"; }

# "" - do not use, overrides system echo to enforce _echo usage
echo() { _ERR "Use _echo instead of echo"; }

# "_str_contains $haystack $needle" - returns 0 if $needle is contained in $haystack, ex: if _str_contains abc b; ...
_str_contains() { [ -z "$2" ] || [ -n "$1" ] && [ -z "${1##*$2*}" ]; }

# "_trap $callback $signal..." - passes $signal as argument 1 to $callback, var prefix: "__trap_", ex: _trap 'echo $1' INT TERM EXIT
_trap() { __trap_cb="$1"; shift; for __trap_s in "$@" ; do trap "$__trap_cb $__trap_s" "$__trap_s"; done; unset __trap_cb __trap_s; }

# "_safe_dquoteval $value" - prepends backslash, backtick/backquote, dollar-sign, and double-quote in $value with \ and wraps the result in double-quotes for use in eval'd double-quoted strings, ex: eval "echo $(_safe_dquoteval "\$(date)")"
# WARNING: Do NOT wrap the output of this function in escaped double-quotes at the call site! WRONG: eval "echo \"$(_safe_dquoteval "\$(date)")\""
_safe_dquoteval() {  printf '"'; printf '%s' "$1" | sed 's/[\\`$"]/\\&/g'; printf '"'; }

# "_safe_eval_setvar $name $value" - validates $name and sanitizes $value using _safe_dquoteval before setting the variable using eval
_safe_eval_setvar() {
  { printf '%s' "$1" | grep -q '[^A-Za-z0-9_]'; } && return 1; eval "${1}=$(_safe_dquoteval "$2")"; }

# "_require_bin $command [$pkgname]" - enforces the existence of an executable name in $PATH, var prefix: "__reqbin_", ex: _require_bin btrfs btrfs-progs
_require_bin() { __reqbin_p="$(command -v "$1" ||:)"
  # Ensure that $__reqbin_p is both absolute (starts with "/") and also ends in "/<command_name>" ("/binfile" matches)
  [ "${__reqbin_p%${__reqbin_p#?}}${__reqbin_p#${__reqbin_p%/${1}}}" = "//${1}" ] || _DEPENDENCY_ERR "$1" "$2"; unset __reqbin_p; }

# "_add_cleanup_paths $glob..." - adds paths (globs) to unlink during _CLEANUP, var prefix: "__clnpth_"
_add_cleanup_paths() {
  : "${__file_path_sep:="$(printf '\001')"}"
  for __clnpth_p in "$@"; do
    _str_contains "$__clnpth_p" "$__file_path_sep" && _ERR 'Path contains list separator char'
    __cleanup_paths="${__cleanup_paths-}${__cleanup_paths:+${__file_path_sep}}${__clnpth_p}"
  done; unset __clnpth_p
}

# "_load_info_file $file" - loads K/V pairs from $file into variables named __INFOFILE__${KEY}, var prefix: "__ldinfo_"
_load_info_file() {
  if [ "${1#${1%.info}}"_ != '.info'_ ]; then
    _errecho "WARNING: Expected info (sidecar) file to have an extension of \".info\": ${1}"
  fi
  {
    read -r __ldinfo_v
    case "$__ldinfo_v" in
      '#btrbk-'*) ;;
      *) _ERR "Info (sidecar) file does not start with a #btrbk-v\${VERSION} line: ${1}"
    esac
    while IFS="=" read -r __ldinfo_k __ldinfo_v; do
      case "$__ldinfo_k" in
        '') ;;
        '#'*) ;;
        *) _safe_eval_setvar "__INFOFILE__${__ldinfo_k}" "$__ldinfo_v" || _ERR "Info (sidecar) file has an invalid key: ${1}"
      esac
    done
  } < "$1"; unset __ldinfo_k __ldinfo_v
}

DD_BLOCKFACTOR=32
# "_dd_safe $infile[=/dev/stdin|file|...] $blocksize[=$((32 * 1024 * 1024))] [$ddarg...]"
_dd_safe() {
  # _dd_safe $count_bytes[=-1] $skip_bytes[=0] $blockbytes[=($countbytes|$skipbytes)]
  # dd always outputs full obs blocks (it will block until it can do so), thus we should leverage that
  # to determine the amount of bytes read by dd's status output of records (we NEVER want a partial!)
  # dd if=(/dev/stdin|file|?) obs=$blocksize | dd ibs=$blocksize count=? skip=?
  # Partial or zero read can only happen once, then we're done reading (as the first dd will block until it has an output block to write)
  # * Blocking also happens for skip if dd input is normalized!
  # * Count and skip can't both be 0

  # This function should just do The Right Thing under any circumstance
  # * if dd doesn't support fullblock we need to normalize the stream (dd obs=? | dd ...) loop and check its output
  #   or not use count
  #   * if $skipbytes > 0 we need to read that many bytes to /dev/null before reading $countbytes to stdout
  # NOTE: busybox dd only reports blocks in and out!

  # Without fullblock (force sync input reads with a pipe):
  # See: https://unix.stackexchange.com/questions/32988/why-does-dd-from-dev-random-give-different-file-sizes/192092#192092
  # dd if=$infile obs=$blocksize | dd $ddarg bs=$blocksize

  # With fullblock:
  # dd $ddarg if=$infile iflag=fullblock bs=$blocksize

  __ddsafe_if="${1:-/dev/stdin}"; shift
  __ddsafe_bs="${1:-$((32 * 1024 * 1024))}"; shift
  _test_parse_num "$__ddsafe_bs"

  if [ -n "$DD_IFLAG_FULLBLOCK" ]; then
    dd $__ddsafe_args if="$__ddsafe_if" iflag=fullblock bs=$__ddsafe_bs
  else
    [ $(($__ddsafe_bs % $DD_BLOCKFACTOR)) -eq 0 ] || _ERR "_dd_safe: argument 2 (block size) must be a multiple of $DD_BLOCKFACTOR"
    dd if="$__ddsafe_if" ibs="$(($__ddsafe_bs / $DD_BLOCKFACTOR))" obs=$__ddsafe_bs | dd $__ddsafe_args bs=$__ddsafe_bs
  fi

  __ddsafe_totalbytes="${1:--1}"; shift # -1 for infinite
  _test_parse_num "$__ddsafe_totalbytes"
  #[ $__ddsafe_totalbytes -lt $INTMAX ] || _ERR 'Ambiguous size for total bytes'
  # TODO: _test_num instead

  __ddsafe_blockbytes="${1:--1}"; shift
  _test_parse_num "$__ddsafe_blockbytes"
  [ $__ddsafe_blockbytes -le 0 ] && __ddsafe_blockbytes=$__ddsafe_totalbytes

  __ddsafe_nullretries="${1:--1}"; shift # -1 for infinite
  _test_parse_num "$__ddsafe_nullretries"
  # If totalbytes is -1 read until EOF (dd reads 0 bytes)
  # direct STDOUT of dd to shell STDOUT
  # direct STDERR of dd to grep/whatever then into variable $__dd_safe_readbytes

  __ddsafe_reads=0
  __ddsafe_readbytes=0
  __ddsafe_remaining=0
  __ddsafe_retrycount=0

  while : ; do
    if [ $__ddsafe_nullretries -gt 0 ]; then
      [ $__ddsafe_retrycount -lt $__ddsafe_nullretries ] || { _errecho "WARNING: Partial read"; break; }
    fi

    if [ $__ddsafe_totalbytes -gt 0 ]; then

      __ddsafe_remaining=$(($__ddsafe_totalbytes - $__ddsafe_readbytes))
      [ $(($__ddsafe_remaining / $__ddsafe_blockbytes)) -lt 1 ] && __ddsafe_blockbytes=$(($__ddsafe_remaining % $__ddsafe_blockbytes))
    fi
    #_errecho "dd bs=${__ddsafe_blockbytes} count=1"
    { __ddsafe_ddstatus="$(dd bs=${__ddsafe_blockbytes} obs=3 count=1 "$@" 2>&1 1>&3 | grep -m 2 '^[0-9]\++[0-9]\+ records \(in\|out\)$')"; } 3>&1
    [ -n "$__ddsafe_ddstatus" ] || _ERR 'Failed to parse dd status output'
    # First line (records in)
    __ddsafe_records_in="${__ddsafe_ddstatus%% records in"$NL"*}"
    # Last line (records out)
    __ddsafe_records_out="${__ddsafe_ddstatus##"${__ddsafe_ddstatus%%"$NL"*}$NL"}"
    __ddsafe_records_out="${__ddsafe_records_out% records out}"
    [ ${#__ddsafe_records_in} -eq 3 ] && [ -z "${__ddsafe_records_in#?+?}" ] || _ERR 'Failed to parse dd records in'
    [ ${#__ddsafe_records_out} -eq 3 ] && [ -z "${__ddsafe_records_out#?+?}" ] || _ERR 'Failed to parse dd records out'

   _errecho "RECORDS: (${__ddsafe_records_in#?+?})"
    exit
    __ddsafe_records_out_part="${__ddsafe_records_out_full#*+}"
    _errecho "IN: ${__ddsafe_records_out_full}+${__ddsafe_records_out_part}"
    exit
    __ddsafe_reads=$((__ddsafe_reads + 1))
    __ddsafe_ddbytes=$((${__ddsafe_ddbytes%% bytes*} + 0))

    #_errecho "READ: $__ddsafe_ddbytes bytes"

    if [ $__ddsafe_ddbytes -le 0 ]; then
      _errecho "WARNING: 0 byte read"
      __ddsafe_retrycount=$(($__ddsafe_retrycount + 1))
      continue
    fi

    # Read >0 bytes
    __ddsafe_retrycount=0
    __ddsafe_readbytes="$(_safe_add $__ddsafe_readbytes $__ddsafe_ddbytes)"

    [ $__ddsafe_readbytes -eq $__ddsafe_totalbytes ] && break
  done
  _errecho "Total reads: ${__ddsafe_reads}"
}

_test_source() {
  # Verifies the beginning and end of the stream
  __tstsrc_total_bytes=$(($2 + 0))
  __SENDSTREAM__subvolname=
  _reconstruct_source "$1" "$2" "$3" $((1024 * 1024)) 0 | {
    # NOTE: The send stream stores number values as little-endian (0x3c, 0x00 is decimal value 60, not 15360)
    # Thus we can manipulate them as number strings using od and and other tools, as they will terminate reading
    # on the first 0x00 (null) byte
    # See: https://btrfs.wiki.kernel.org/index.php/Design_notes_on_Send/Receive

    # send stream header: 17 bytes
    dd status=none bs=1 count=13 | grep -q ^btrfs-stream         || _ERR "bad magic value" # magic "btrfs-stream\0"
    dd status=none bs=1 count=4  | grep -q ^"$(printf '\001')"\$ || _ERR "stream version != 0x01" # stream version

    # send command header: 10 bytes
    dd status=none bs=1 skip=4 count=0 # command size; unneeded as the only info we want is in TLV1
    # Expect and validate a "Send subvolume or snapshot" command (0x01 or 0x02)
    __tstsrc_cmdtype=$(($(dd status=none bs=1 count=2 | od -An -vtu2) + 0)) # command type
    [ $__tstsrc_cmdtype -eq 1 ] || [ $__tstsrc_cmdtype -eq 2 ] || _ERR "command type != 0x01|0x02 "
    # NOTE: We don't perform a CRC32 check here as we have no easy way of getting the bytes to checksum (they contain 0x0 anyway!)
    dd status=none bs=1 skip=4 count=0 # CRC32

    # send TLV1 (name) header: 4 bytes
    dd status=none bs=1 count=2 | grep -q ^"$(printf '\017')"\$ || _ERR "TLV1 type != 0x0f"
    __tstsrc_subvolname_size=$(($(dd status=none bs=1 count=2 | od -An -vtu2) + 0))

    # send TLV1 (name) payload: $subvolname_size bytes
    __SENDSTREAM__subvolname="$(dd status=none bs=1 count=$__tstsrc_subvolname_size)"

    # skip to end - 6 bytes (send end command)
    # TODO? Skip this check altogether and WARN if $__total_bytes is over $4 and fullblock or skip_bytes is unavailable
    dd status=none bs=1M iflag=fullblock,skip_bytes skip=$(($__tstsrc_total_bytes - 6 - $__tstsrc_subvolname_size - 31)) count=0
    dd status=none bs=1 count=2 | grep -q ^"$(printf '\025')"\$ || _ERR "send end fail"
    dd status=none bs=1 count=4 | grep -q ^"$(printf '\120\154\311\235')"\$ || _ERR "send end fail"
  }
  unset __tstsrc_total_bytes __tstsrc_subvolname_size __tstsrc_cmdtype
}

_reconstruct_source() {
  __source_list="$1"
  __total_bytes=$(($2 + 0))
  __toolchain="${3-}"
  __block_size=$((${4:-BLOCKSIZE} + 0))
  __source_destroy="${5:-0}"

  # TODO Does this belong here or below in main? (Prob. the latter)
  if [ "$INPLACE" -eq 1 ]; then
    # TODO ASK FOR CONFIRMATION!
    _errecho "WARNING: Disabling SIGINT (Ctrl-c) for destructive operation!"
    trap - INT
  fi

  __read_bytes=0
  __remaining_bytes="$__total_bytes"
  for __f in $__source_list; do
    __f_size="$(stat -c%s "$__f")"
    __f_remaining_bytes="$__f_size"
    __f_pos=0
    __dd_bytes="$__block_size"
    while : ; do
      [ $__remaining_bytes -gt 0 ] || break
      [ $__f_remaining_bytes -gt 0 ] || break

      [ $__dd_bytes -le $__remaining_bytes ] || __dd_bytes=$__remaining_bytes
      [ $__dd_bytes -le $__f_remaining_bytes ] || __dd_bytes=$__f_remaining_bytes


      # TODO? Use dd without unportable options and WARN if fullblock, skip_bytes, or count_bytes is unavailable
      # This would require parsing dd's status output to determine the number of bytes read
      # _errecho "Read from: $__rpos"
      dd status=none if="$__f" bs=1M skip="$__f_pos" count="$__dd_bytes" iflag=fullblock,skip_bytes,count_bytes

      __f_pos=$(($__f_pos + $__dd_bytes))
      __f_remaining_bytes=$(($__f_remaining_bytes - $__dd_bytes))
      __read_bytes=$(($__read_bytes + $__dd_bytes))
      __remaining_bytes=$(($__remaining_bytes - $__dd_bytes))

      # TODO fallocate
      # _errecho "fallocate"
      #fallocate --keep-size --punch-hole --offset $readpos --length $readsize $infile >&2 &
    done
    #_errecho "FILE DONE: ${__f}"
  done
  #_errecho "READ DONE"
}

_USAGE() {
  >&2 printf \
'usage: [TESTRUN=1] [BLOCKSIZE=<bytes>] [INPLACE=1] [TRACE=1] %s <info-file> <target-subvol>

Environment variables:

TESTRUN=1  Perform a test run of BLOCKSIZE bytes (disables INPLACE)

BLOCKSIZE=<bytes>  Set the amount of bytes read (and truncated, if INPLACE) at a time
                   Note that shell arithmetic $((...)) can be used to calculate values, for example
                   BLOCKSIZE=$((64 * 1024 * 1024)) sets the value to 67108864 (64MiB), the default

INPLACE=1  Truncate the head of the source raw backup file (fallocate --punch-hole) as its read;
           a mandatory test run will automatically be performed and must complete successfully
           === WARNING ===
           THIS OPTION DESTROYS THE RAW BACKUP SOURCE FILE -- ENSURE THAT YOU HAVE ANOTHER COPY
           OF THE SNAPSHOT OR CAN AFFORD TO LOSE THE DATA BEFORE ENABLING THIS OPTION!
           If the restore operation fails for any reason the file will be PERMANENTLY CORRUPTED,
           so only use if absolutely necessary; e.g. the backup file and target are on the same
           btrfs filesystem and the space used by the file is needed to restore the subvolume

TRACE=1    Enable shell trace output

' "$(basename "${0}")"
  exit 1
}

_ERR() {
  _errecho "ERROR: ${1}"
  [ "${2:-0}" -eq 1 ] && { _errecho; USAGE; }
  exit "${3:-1}"
}

_DEPENDENCY_ERR() {
  >&2 printf 'ERROR: "%s" not found in $PATH%s\n' "$1" "${2:+"; is the \"${2}\" package (or equivalent) installed?"}"
  exit 9
}

_CLEANUP() ( # VAR PREFIX: __clnup_
  set +e
  __clnup_l="${__clnup_paths-}"; while [ "$__clnup_l" != "${__clnup_l2-}" ]; do
    __clnup_l="${__clnup_l2:-${__clnup_l}}"
    __clnup_l2="${__clnup_l%${__file_path_sep}*}"
    __clnup_v="${__clnup_l#${__clnup_l2}${__file_path_sep}}"
    rm "$__clnup_v"
  done; unset __clnup_l __clnup_l2 __clnup_v
)

_SHUTDOWN() {
  [ "${__shutdown_bypass-0}" -eq 1 ] && return
  __shutdown_bypass=1
  case "${1-}" in
    INT|TERM) trap - INT TERM;;
    EXIT) : ;;
    *) _ERR "Invalid shutdown signal: $1" 0 127
  esac
  _echo "==> SHUTDOWN: $1"
  _CLEANUP
}

_MAIN() {
  _trap _SHUTDOWN INT TERM EXIT

  # Required dependencies
  _require_bin grep     grep
  _require_bin sed      sed
  _require_bin btrfs    btrfs-progs
  _require_bin basename coreutils
  _require_bin dirname  coreutils
  _require_bin dd       coreutils
  _require_bin od       coreutils
  _require_bin readlink coreutils
  _require_bin stat     coreutils

  # Feature-test dd
  DD_IFLAG_FULLBLOCK=
  dd_iflag_skip_bytes=
  dd_iflag_count_bytes=
  dd_helptxt="$(dd --help 2>&1)" \
  || dd_helptxt="$(dd -h 2>&1)" \
  || _ERR "Failed to parse help text for dd"
  [ -z "${dd_helptxt##*fullblock *}" ]   && DD_IFLAG_FULLBLOCK=' iflag=fullblock'
  [ -z "${dd_helptxt##*skip_bytes *}" ]  && dd_iflag_skip_bytes=' iflag=skip_bytes'
  [ -z "${dd_helptxt##*count_bytes *}" ] && dd_iflag_count_bytes=' iflag=count_bytes'
  # Ex. usage: iflags=${DD_IFLAG_FULLBLOCK}${dd_iflag_skip_bytes}; dd bs=1M $iflags

  if [ "$INPLACE" -eq 1 ]; then
    _require_bin fallocate  util-linux
    _require_bin findmnt    util-linux

    # Feature-test fallocate
    falloc_punch_hole=
    falloc_helptxt="$(fallocate --help 2>&1)" \
    || falloc_helptxt="$(fallocate -h 2>&1)" \
    || _ERR "Failed to parse help text for fallocate"
    [ -z "${falloc_helptxt##*--punch-hole*}" ] && falloc_punch_hole=' --punch-hole'

    # TODO Feature-test findmnt
  fi

  # Script arguments
  source_info="${1-}"
  target="${2-}"

  # Source check
  if [ -z "$source_info" ]; then
    _ERR "Info (sidecar) file was not specified" 1
  elif ! [ -r "$source_info" ]; then
    _ERR "Info (sidecar) file doesn't exist or isn't readable: ${source_info}"
  fi

  source_dir="$(dirname "$(readlink -f "$source_info")")"
  source_info="${source_dir}/${source_info##*/}" # Canonicalize
  _load_info_file "$source_info"
  source_name="${__INFOFILE__FILE##*/}"
  subvol_name="${source_name%.btrfs*}"
  source="${source_dir}/${source_name}"

  if [ "${__INFOFILE__INCOMPLETE-0}" -eq 1 ]; then
    _ERR "Raw backup file is marked incomplete"
  fi

  if [ -n "${__INFOFILE__split+x}" ]; then
    source_glob="${source}.split_*"
  fi

  file_list=${source_glob:-$source}

  # Source sanity checks and preliminary info gathering
  toolchain=
  total_size=0
  for f in $file_list; do
    # Attempt capturing the filesystem name which houses the source file(s) to test for fallocate --punch-hole compat
    [ "$INPLACE" -eq 1 ] && "${source_fs:="$(findmnt -n -o FSTYPE --target "$f")"}"
    [ -r "$f" ] || _ERR "File doesn't exist or isn't readable: ${f}"
    fsize="$(stat -c%s "$f")"
    [ "$fsize" -gt 0 ] || _ERR "Source file appears empty (stat reported 0 bytes or errored): ${f}"
    total_size=$(($total_size + $fsize))
  done

  # $do_test_source && ...
  _test_source "$file_list" $total_size "$toolchain" || _ERR "Source test failed"

  _echo "NAME FROM STREAM: $__SENDSTREAM__subvolname" # Wait, what?
  [ -n "${__SENDSTREAM__subvolname-}" ] && subvolname="$__SENDSTREAM__subvolname"

  # Target sanity checks
  if [ -e "${target}/${subvol_name}" ]; then
    _ERR "Restore target exists, aborting: ${target}/${subvol_name}"
  fi

  set +e; target_info="$(btrfs subvolume show "$target")"; set -e
  [ $? -eq 0 ] || target_info=

  if [ -z "$target_info" ]; then
    _ERR "Restore target does not appear to be a btrfs subvolume (\"btrfs sub show '${target}'\" failed)"
  fi

  if printf '%s' "$target_info" | grep Flags: | grep -q readonly; then
    _ERR "Restore target appears to be readonly: ${target}"
  fi

  # Main
  _reconstruct_source "$file_list" $total_size "$toolchain" "$BLOCKSIZE" 0 \
  | btrfs receive -v "$target" #; _echo ">>>${?}" # "$target"

  exit 0
}

total=$((1024 * 1024 * 1024 + 124283))
 dd status=none bs=1GiB if=/dev/urandom | _dd_safe $total $((1024 * 1024 * 512)) 5 | dd status=none bs=128M of=/dev/null
exit

_MAIN "$@"

##### TODO
# * Build $toolchain pipeline string and eval it safely in _reconstruct_source
# * TESTRUN: make sure key can decrypt, or passphrase is correct, all utilities work, etc before INPLACE destructive read
# * ? unencrypt
#   - openssl
#     - keyfile
#     - kdf
#   - gpg
# * ? uncompress
#   - xz
#   - gzip
