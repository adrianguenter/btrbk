#!/usr/bin/dash
# TODO: ^^^^^^^ Revert to /bin/sh

set -eu # exit on error, error on unset
[ "${TRACE:-0}" -gt 0 ] && set -x # TRACE=1 btrbk-restore-raw ...

_str_contains() { [ -n "$1" ] && [ -z "${1##*$2*}" ] || [ -z "$2" ] ;}
_trap() { cb="$1"; shift; for s in "$@" ; do trap "$cb $s" "$s"; done ;}

_USAGE() {
  >&2 echo "$(basename "${0}"): <source-file> <dest-subvol>"
  exit 1
}

_ERR() {
  >&2 echo "ERROR: ${1}"
  [ "${2:-0}" -eq 1 ] && { echo; _USAGE; }
  exit "${3:-1}"
}

_CLEANUP() (
  set +e
  list="${__cleanup_paths-}"
  while [ "$list" != "${_list-}" ]; do
    list="${_list:-${list}}"; _list="${list%${__cleanup_path_sep}*}"
    val="${list#${_list}${__cleanup_path_sep}}"
    rm "$val"
  done
)

_SHUTDOWN() {
  [ "${__shutdown_bypass-0}" -eq 1 ] && return
  __shutdown_bypass=1
  case "${1-}" in
    INT|TERM) trap - INT TERM;;
    EXIT) : ;;
    *) _ERR "Invalid shutdown signal: $1" 0 127
  esac
  echo "==> SHUTDOWN: $1"
  _CLEANUP
}

_add_cleanup_paths() {
  : "${__cleanup_path_sep:="$(printf '\001')"}"
  for p in "$@"; do
    _str_contains "$p" "$__cleanup_path_sep" && _ERR 'Path contains list separator char'
    __cleanup_paths="${__cleanup_paths-}${__cleanup_paths:+${__cleanup_path_sep}}${p}"
  done
}

_read_info_file() {
  while IFS="=" read -r __k __v; do
    case "$__k" in
      '#'*) ;;
      *) eval "__INFO__${__k}='${__v}'"
    esac
  done < "$1"
}

_checkbin() {
  if ! [ ${1+x} ]; then
    _ERR "not exists"
  elif ! [ -x "$1" ]; then
    _ERR "$1 is not executable"
  fi
}

_trap '_SHUTDOWN' INT TERM EXIT

#_add_cleanup_paths /tmp/testa
#_add_cleanup_paths /tmp/testb* /tmp/testc testd test/e test_f/oo/b"\014"ar

bin_btrfs="$(command -v btrfs)"
bin_dd="$(command -v dd)"
bin_fallocate="$(command -v fallocate)"
bin_findmnt="$(command -v findmnt)"
bin_gpg="$(command -v gpg)"
bin_mkfifo="$(command -v mkfifo)"
bin_openssl="$(command -v openssl)"
bin_stat="$(command -v stat)"

source="${1-}"
source_info="${1-}.info"
destination="${2-}"

# Source check
if [ -z "$source" ]; then
  _ERR "Raw backup file was not specified" 1
elif ! [ -r "$source" ]; then
  _ERR "Raw backup file doesn't exist or isn't readable: ${source}"
elif ! [ -r "$source_info" ]; then
  _ERR "Sidecar info file doesn't exist or isn't readable: ${source_info}"
fi

_read_info_file "$source_info"

source_size=$("$bin_stat" -c%s "$source")

if [ "${__INFO__INCOMPLETE-0}" -eq 1 ]; then
  _ERR "Raw backup file is marked incomplete"
elif [ "$source_size" -eq 0 ]; then
  _ERR "Source file appears empty (size is 0 bytes)"
fi

# Destination check
echo "$destination"

BUFFER_SIZE="${BUFFER_SIZE:-64MiB}"
#: "${BUFFER_SIZE:=$((64 * 1024 * 1024))}"

fifo="${source}.fifo~${$}"
_add_cleanup_paths "$fifo"
readpos=0

"$bin_mkfifo" -m 0600 "$fifo"

dd if=/dev/zero bs=1M count=1024 >$fifo &
dd of=/dev/null <$fifo

exit

_checkbin dd

echo $bin_findmnt

rm -rf read-delete-test/

mkdir read-delete-test

#infile=read-delete-test/a
infile=read-delete.dat
outfile=read-delete-test/b
fifo=read-delete-test/fifo

infile_fs=$(Findmnt -n -o FSTYPE --target)
echo $infile_fs
exit

#dd if=/dev/urandom of=$infile bs=1M count=1841129875 iflag=count_bytes

#tail -c1M $infile | sha256sum

filesize=$(stat -c%s "$infile")
readsize=$((64 * 1024 * 1024))
readpos=0

mkfifo -m 0600 $fifo

dd if=/dev/zero bs=1M count=1024 >$fifo &
dd of=/dev/null <$fifo

echo "done"

exit

{
  while : ; do
    #echo "Read from: $readpos"
    dd status=none if=$infile bs=1M skip=$readpos count=$readsize iflag=count_bytes,skip_bytes >&3
    #echo "fallocate"
    #fallocate --keep-size --punch-hole --offset $readpos --length $readsize $infile >&2 &
    readpos=$((readpos + readsize))
    [ $readpos -lt $filesize ] || { >&2 echo "DONE"; break; }
  done
} &

echo "Read FIFO"
dd status=none bs=1M if=$fifo of=$outfile #count=$filesize iflag=count_bytes

#echo "Digest outfile"
#tail -c1M $outfile | sha256sum

#du -k read-delete-test/


exit


#dd status=none if=$testfile bs=1M skip=43G iflag=skip_bytes | sha256sum
#time fallocate -p -o 0 -l43G $testfile
#btrfs fi du $testfile
#dd status=none if=$testfile bs=1M skip=43G iflag=skip_bytes | sha256sum

for i in $(seq 0 9); do
  dd if=$testfile bs=1M count=1M iflag=count_bytes,skip_bytes,fullblock >> $testfile.dup
  cut -b 1048576- $testfile
  #dd if=$testfile bs=1M count=1M skip=${i}M iflag=count_bytes,skip_bytes,fullblock >> $testfile.dup  
done

ls -alF $testfile $testfile.dup

sha256sum $testfile $testfile.dup

rm $testfile $testfile.dup
