#!/usr/bin/dash
# TODO: ^^^^^^^ Revert to /bin/sh

set -eu # exit on error, error on unset
[ "${TRACE:=0}" -eq 1 ] && set -x # TRACE=1 btrbk-restore-raw ...

: "${TESTRUN:=0}" # TESTRUN=1 btrbk-restore-raw ...

: "${INPLACE:=0}" # INPLACE=1 btrbk-restore-raw ...

: "${BLOCKSIZE:=$((64 * 1024 * 1024))}" # BLOCKSIZE=$((1024 * 1024 * 1024)) btrbk-restore-raw ...

# "_echo [$string...]", var prefix: "__echo_"
_echo() { [ $# -lt 2 ] && { printf '%s\n' "${1-}"; return; }
  __echo_s=; for __echo_i in "$@"; do __echo_s="$__echo_s $__echo_i"; done; printf '%s\n' "$__echo_s"; unset __echo_s __echo_i; }
_errecho() { >&2 _echo "$@"; }
echo() { _echo "$@"; } # Override system echo

# "_str_contains $haystack $needle", returns 0 if <needle> is contained in <haystack>, ex: "if _str_contains abc b; ..."
_str_contains() { [ -z "$2" ] || [ -n "$1" ] && [ -z "${1##*$2*}" ]; }

# "_trap $callback> $signal...", var prefix: "__trap_", passes <signal> as argument 1 to <callback>, ex: "_trap 'echo $1' INT TERM EXIT"
_trap() { __trap_cb="$1"; shift; for __trap_s in "$@" ; do trap "$__trap_cb $__trap_s" "$__trap_s"; done; unset __trap_cb __trap_s; }

# "_safe_dquoteval $value", prepends backslash, backtick/backquote, dollar-sign, and double-quote in $value with backslash (\) for use in eval'd double quoted strings, ex: eval "echo \"$(_safe_dquoteval "\$(date)")\""
_safe_dquoteval() {  printf '%s' "$1" | sed 's/[\\`$"]/\\&/g'; }
# "_safe_eval_setvar $name $value", validates $name and sanitizes $value using _safe_dquoteval
_safe_eval_setvar() {
  { printf '%s' "$1" | grep -q '[^A-Za-z0-9_]'; } && return 1; eval "${1}=\"$(_safe_dquoteval "$2")\""; }

# "_require_bin $command [$pkgname]", var prefix: "__reqbin_", ex: "_require_bin btrfs btrfs-progs"
_require_bin() { __reqbin_p="$(command -v "$1" ||:)"
  # Ensure that $__reqbin_p is both absolute (starts with "/") and also ends in "/<command_name>" ("/binfile" matches)
  [ "${__reqbin_p%${__reqbin_p#?}}${__reqbin_p#${__reqbin_p%/${1}}}" = "//${1}" ] || _DEPENDENCY_ERR "$1" "$2"; unset __reqbin_p; }

# "_load_info_file $file", var prefix: "__ldinfo_"
_load_info_file() {
  # Reads a raw backup sidecar file into the current environment with a var (key) prefix of __INFOFILE__
  if [ "${1#${1%.info}}"_ != '.info'_ ]; then
    _errcho "WARNING: Expected info (sidecar) file to have an extension of \".info\": ${1}"
  fi
  {
    read -r __ldinfo_v
    case "$__ldinfo_v" in
      '#btrbk-'*) ;;
      *) _ERR "Info (sidecar) file does not start with a #btrbk-v\${VERSION} line: ${1}"
    esac
    while IFS="=" read -r __ldinfo_k __ldinfo_v; do
      case "$__ldinfo_k" in
        '') ;;
        '#'*) ;;
        *) _safe_eval_setvar "__INFOFILE__${__ldinfo_k}" "$__ldinfo_v" || _ERR "Info (sidecar) file has an invalid key: ${1}"
      esac
    done
  } < "$1"; unset __ldinfo_k __ldinfo_v
}

_reconstruct_source() {
  __source_list="$1"
  __total_bytes="$2"
  __toolchain="${3-}"
  __block_size="${4:-BLOCKSIZE}"
  __source_destroy="${5:-0}"

  # TODO Does this belong here or below in main? (Prob. the latter)
  if [ "$INPLACE" -eq 1 ]; then
    # TODO ASK FOR CONFIRMATION!
    _errecho "WARNING: Disabling SIGINT (Ctrl-c) for destructive operation!"
    trap - INT
  fi

  __read_bytes=0
  __remaining_bytes="$__total_bytes"
  for __f in $__source_list; do
    __f_size="$(stat -c%s "$__f")"
    __f_remaining_bytes="$__f_size"
    __f_pos=0
    __dd_bytes="$__block_size"
    while : ; do
      [ $__remaining_bytes -gt 0 ] || break
      [ $__f_remaining_bytes -gt 0 ] || break

      [ $__dd_bytes -le $__remaining_bytes ] || __dd_bytes=$__remaining_bytes
      [ $__dd_bytes -le $__f_remaining_bytes ] || __dd_bytes=$__f_remaining_bytes

      #_echo "Read from: $__rpos"
      dd status=none if="$__f" bs=1M skip="$__f_pos" count="$__dd_bytes" iflag=fullblock,skip_bytes,count_bytes

      __f_pos=$(($__f_pos + $__dd_bytes))
      __f_remaining_bytes=$(($__f_remaining_bytes - $__dd_bytes))
      __read_bytes=$(($__read_bytes + $__dd_bytes))
      __remaining_bytes=$(($__remaining_bytes - $__dd_bytes))
      #_echo "fallocate"
      #fallocate --keep-size --punch-hole --offset $readpos --length $readsize $infile >&2 &
      break # TODO REMOVE
    done
    _errecho "FILE DONE: ${__f}"
  done
  _errecho "READ DONE"
}

_USAGE() {
  >&2 printf \
'usage: [TESTRUN=1] [BLOCKSIZE=<bytes>] [INPLACE=1] [TRACE=1] %s <info-file> <target-subvol>

Environment variables:

TESTRUN=1  Perform a test run of BLOCKSIZE bytes (disables INPLACE)

BLOCKSIZE=<bytes>  Set the amount of bytes read (and truncated, if INPLACE) at a time
                   Note that shell arithmetic $((...)) can be used to calculate values, for example
                   BLOCKSIZE=$((64 * 1024 * 1024)) sets the value to 67108864 (64MiB), the default

INPLACE=1  Truncate the head of the source raw backup file (fallocate --punch-hole) as its read;
           a mandatory test run will automatically be performed and must complete successfully
           === WARNING ===
           THIS OPTION DESTROYS THE RAW BACKUP SOURCE FILE -- ENSURE THAT YOU HAVE ANOTHER COPY
           OF THE SNAPSHOT OR CAN AFFORD TO LOSE THE DATA BEFORE ENABLING THIS OPTION!
           If the restore operation fails for any reason the file will be PERMANENTLY CORRUPTED,
           so only use if absolutely necessary; e.g. the backup file and target are on the same
           btrfs filesystem and the space used by the file is needed to restore the subvolume

TRACE=1    Enable shell trace output

' "$(basename "${0}")"
  exit 1
}

_ERR() {
  _errecho 'ERROR: ' "$@"
  [ "${2:-0}" -eq 1 ] && { _errecho; USAGE; }
  exit "${3:-1}"
}

_DEPENDENCY_ERR() {
  >&2 printf 'ERROR: "%s" not found in $PATH%s\n' "$1" "${2:+"; is the \"${2}\" package (or equivalent) installed?"}"
  exit 9
}

_CLEANUP() ( # VAR PREFIX: __clnup_
  set +e
  __clnup_l="${__clnup_paths-}"; while [ "$__clnup_l" != "${__clnup_l2-}" ]; do
    __clnup_l="${__clnup_l2:-${__clnup_l}}"
    __clnup_l2="${__clnup_l%${__file_path_sep}*}"
    __clnup_v="${__clnup_l#${__clnup_l2}${__file_path_sep}}"
    rm "$__clnup_v"
  done; unset __clnup_l __clnup_l2 __clnup_v
)

_SHUTDOWN() {
  [ "${__shutdown_bypass-0}" -eq 1 ] && return
  __shutdown_bypass=1
  case "${1-}" in
    INT|TERM) trap - INT TERM;;
    EXIT) : ;;
    *) _ERR "Invalid shutdown signal: $1" 0 127
  esac
  _echo "==> SHUTDOWN: $1"
  _CLEANUP
}

# "_add_cleanup_paths $glob...", var prefix: "__clnpth_"
_add_cleanup_paths() {
  : "${__file_path_sep:="$(printf '\001')"}"
  for __clnpth_p in "$@"; do
    _str_contains "$__clnpth_p" "$__file_path_sep" && _ERR 'Path contains list separator char'
    __cleanup_paths="${__cleanup_paths-}${__cleanup_paths:+${__file_path_sep}}${__clnpth_p}"
  done; unset __clnpth_p
}

_MAIN() {
  _trap _SHUTDOWN INT TERM EXIT

  # Required dependencies
  _require_bin grep     grep
  _require_bin sed      sed
  _require_bin btrfs    btrfs-progs
  _require_bin basename coreutils
  _require_bin dirname  coreutils
  _require_bin dd       coreutils
  _require_bin readlink coreutils
  _require_bin stat     coreutils
  if [ "$INPLACE" -eq 1 ]; then
    _require_bin findmnt  util-linux
  fi

  # Script arguments
  source_info="${1-}"
  target="${2-}"

  # Source check
  if [ -z "$source_info" ]; then
    _ERR "Info (sidecar) file was not specified" 1
  elif ! [ -r "$source_info" ]; then
    _ERR "Info (sidecar) file doesn't exist or isn't readable: ${source_info}"
  fi

  source_dir="$(dirname "$(readlink -f "$source_info")")"
  source_info="${source_dir}/${source_info##*/}" # Canonicalize
  _load_info_file "$source_info"
  source_name="${__INFOFILE__FILE##*/}"
  subvol_name="${source_name%.btrfs*}"
  source="${source_dir}/${source_name}"

  if [ "${__INFOFILE__INCOMPLETE-0}" -eq 1 ]; then
    _ERR "Raw backup file is marked incomplete"
  fi

  if [ -n "${__INFOFILE__split+x}" ]; then
    source_glob="${source}.split_*"
  fi

  file_list=${source_glob:-$source}

  # Source sanity checks and preliminary info gathering
  toolchain=
  total_size=0
  for f in $file_list; do
    # Attempt capturing the filesystem name which houses the source file(s) to test for fallocate --punch-hole compat
    [ "$INPLACE" -eq 1 ] && "${source_fs:="$(findmnt -n -o FSTYPE --target "$f")"}"
    [ -r "$f" ] || _ERR "File doesn't exist or isn't readable: ${f}"
    fsize="$(stat -c%s "$f")"
    [ "$fsize" -gt 0 ] || _ERR "Source file appears empty (size is 0 bytes): ${f}"
    total_size=$(($total_size + $fsize))
  done

  # Target sanity checks
  if [ -e "${target}/${subvol_name}" ]; then
    _ERR "Restore target exists, aborting: ${target}/${subvol_name}"
  fi

  set +e; target_info="$(btrfs subvolume show "$target")"; set -e
  [ $? -eq 0 ] || target_info=

  if [ -z "$target_info" ]; then
    _ERR "Restore target does not appear to be a btrfs subvolume (\"btrfs sub show '${target}'\" failed)"
  fi

  if printf '%s' "$target_info" | grep Flags: | grep -q readonly; then
    _ERR "Restore target appears to be readonly: ${target}"
  fi

  # Main
  _reconstruct_source "$file_list" $total_size "$toolchain" "$BLOCKSIZE" 0 \
  | btrfs receive -v "$target" #; _echo ">>>${?}" # "$target"

  exit 0
}

_MAIN "$@"

##### TODO
# * Build $toolchain pipeline string and eval it safely in _reconstruct_source
# * TESTRUN: make sure key can decrypt, or passphrase is correct, all utilities work, etc before INPLACE destructive read
# * ? unencrypt
#   - openssl
#     - keyfile
#     - kdf
#   - gpg
# * ? uncompress
#   - xz
#   - gzip
