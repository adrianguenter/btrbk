#!/usr/bin/dash
# TODO: ^^^^^^^ Revert to /bin/sh

set -eu # exit on error, error on unset
[ "${TRACE:-0}" -eq 1 ] && set -x # TRACE=1 btrbk-restore-raw ...

[ "${INPLACE:-0}" ] # INPLACE=1 btrbk-restore-raw ...

_str_contains() { [ -n "$1" ] && [ -z "${1##*$2*}" ] || [ -z "$2" ] ; }
_trap() { __cb="$1"; shift; for __s in "$@" ; do trap "$__cb $__s" "$__s"; done; unset __cb __s ; }

_USAGE() {
  >&2 echo "usage: [INPLACE=1|0] [TRACE=1|0] $(basename "${0}") <source-file> <dest-subvol>\n"
  >&2 echo "Environment variables:"
  >&2 echo "\nINPLACE  1: Incrementally truncate the head of the source file (fallocate --punch-hole) as its read"
  >&2 echo "            === WARNING ==="
  >&2 echo "            THIS OPTION DESTROYS THE RAW BACKUP SOURCE FILE"
  >&2 echo "            If the restore operation fails for any reason the file will be PERMANENTLY CORRUPTED!"
  >&2 echo "            Only use this if absolutely necessary -- e.g., source and target are on the same filesystem"
  >&2 echo "            and space is at a premium. ENSURE THAT YOU HAVE ANOTHER COPY OF THIS BACKUP OR CAN AFFORD TO"
  >&2 echo "            LOSE THE DATA! YOU HAVE BEEN WARNED"
  >&2 echo "         0: (Default) Do not modify the raw backup source file"
  >&2 echo "\nTRACE    1: Print shell trace output"
  >&2 echo "         0: (Default) Disable shell trace output"
  exit 1
}

_ERR() {
  >&2 echo "ERROR: ${1}"
  [ "${2:-0}" -eq 1 ] && { echo; _USAGE; }
  exit "${3:-1}"
}

_DEPENDENCY_ERR() {
  >&2 printf 'ERROR: "%s" not found in $PATH%s\n' "$1" "${2:+"; is the \"${2}\" package (or equivalent) installed?"}"
  exit 9
}

_CLEANUP() (
  set +e
  __l="${__cleanup_paths-}"; while [ "$__l" != "${__l2-}" ]; do
    __l="${__l2:-${__l}}"; __l2="${__l%${__cleanup_path_sep}*}"
    __v="${__l#${__l2}${__cleanup_path_sep}}"
    rm "$__v"
  done; unset __l __l2 __v
)

_SHUTDOWN() {
  [ "${__shutdown_bypass-0}" -eq 1 ] && return
  __shutdown_bypass=1
  case "${1-}" in
    INT|TERM) trap - INT TERM;;
    EXIT) : ;;
    *) _ERR "Invalid shutdown signal: $1" 0 127
  esac
  echo "==> SHUTDOWN: $1"
  _CLEANUP
}

_add_cleanup_paths() {
  : "${__cleanup_path_sep:="$(printf '\001')"}"
  for __p in "$@"; do
    _str_contains "$__p" "$__cleanup_path_sep" && _ERR 'Path contains list separator char'
    __cleanup_paths="${__cleanup_paths-}${__cleanup_paths:+${__cleanup_path_sep}}${__p}"
  done; unset __p
}

_load_info_file() {
  # Reads a raw backup sidecar file into the current environment with a var (key) prefix of __RAWINFO__
  while IFS="=" read -r __k __v; do
    case "$__k" in
      '#'*) ;;
      *) eval "__RAWINFO__${__k}='${__v}'"
    esac
  done < "$1"; unset __k __v
}

_checkbin() {
  if ! [ ${1+x} ]; then
    _ERR "not exists"
  elif ! [ -x "$1" ]; then
    _ERR "$1 is not executable"
  fi
}

_trap _SHUTDOWN INT TERM EXIT

# Required dependencies
bin_btrfs="$(command -v btrfs)" || _DEPENDENCY_ERR btrfs btrfs-progs
bin_dd="$(command -v dd)"       || _DEPENDENCY_ERR dd    coreutils
bin_stat="$(command -v stat)"   || _DEPENDENCY_ERR stat  coreutils

# Optional dependencies
bin_fallocate="$(command -v fallocate)"
bin_findmnt="$(command -v findmnt)"
bin_gpg="$(command -v gpg)"
bin_mkfifo="$(command -v mkfifo)"
bin_openssl="$(command -v openssl)"

# Script arguments
source="${1-}"
source_info="${1-}.info"
destination="${2-}"

# Source check
if [ -z "$source" ]; then
  _ERR "Raw backup file was not specified" 1
elif ! [ -r "$source" ]; then
  _ERR "Raw backup file doesn't exist or isn't readable: ${source}"
elif ! [ -r "$source_info" ]; then
  _ERR "Sidecar info file doesn't exist or isn't readable: ${source_info}"
fi

_load_info_file "$source_info"

source_size=$("$bin_stat" -c%s "$source")

if [ "${__INFO__INCOMPLETE-0}" -eq 1 ]; then
  _ERR "Raw backup file is marked incomplete"
elif [ "$source_size" -eq 0 ]; then
  _ERR "Source file appears empty (size is 0 bytes)"
fi

# Destination check
echo "$destination"

BUFFER_SIZE="${BUFFER_SIZE:-64MiB}"
#: "${BUFFER_SIZE:=$((64 * 1024 * 1024))}"

fifo="${source}.fifo~${$}"
_add_cleanup_paths "$fifo"
readpos=0

"$bin_mkfifo" -m 0600 "$fifo"

# MAIN BODY SEQ
# * ? unsplit
# * ? unencrypt
#   - openssl
#     - keyfile
#     - kdf
#   - gpg
# * ? uncompress
#   - xz
#   - gzip

# FIFO usage w/ dd:
# dd if=/dev/zero bs=1M count=1024 >$fifo &
# dd of=/dev/null <$fifo

rm -rf read-delete-test/

mkdir read-delete-test

#infile=read-delete-test/a
infile=read-delete.dat
outfile=read-delete-test/b
fifo=read-delete-test/fifo

infile_fs=$(Findmnt -n -o FSTYPE --target)
echo $infile_fs
exit

#dd if=/dev/urandom of=$infile bs=1M count=1841129875 iflag=count_bytes

#tail -c1M $infile | sha256sum

filesize=$(stat -c%s "$infile")
readsize=$((64 * 1024 * 1024))
readpos=0

mkfifo -m 0600 $fifo

dd if=/dev/zero bs=1M count=1024 >$fifo &
dd of=/dev/null <$fifo

echo "done"

exit

{
  while : ; do
    #echo "Read from: $readpos"
    dd status=none if=$infile bs=1M skip=$readpos count=$readsize iflag=count_bytes,skip_bytes >&3
    #echo "fallocate"
    #fallocate --keep-size --punch-hole --offset $readpos --length $readsize $infile >&2 &
    readpos=$((readpos + readsize))
    [ $readpos -lt $filesize ] || { >&2 echo "DONE"; break; }
  done
} &

echo "Read FIFO"
dd status=none bs=1M if=$fifo of=$outfile #count=$filesize iflag=count_bytes

#echo "Digest outfile"
#tail -c1M $outfile | sha256sum

#du -k read-delete-test/


exit


#dd status=none if=$testfile bs=1M skip=43G iflag=skip_bytes | sha256sum
#time fallocate -p -o 0 -l43G $testfile
#btrfs fi du $testfile
#dd status=none if=$testfile bs=1M skip=43G iflag=skip_bytes | sha256sum

for i in $(seq 0 9); do
  dd if=$testfile bs=1M count=1M iflag=count_bytes,skip_bytes,fullblock >> $testfile.dup
  cut -b 1048576- $testfile
  #dd if=$testfile bs=1M count=1M skip=${i}M iflag=count_bytes,skip_bytes,fullblock >> $testfile.dup  
done

ls -alF $testfile $testfile.dup

sha256sum $testfile $testfile.dup

rm $testfile $testfile.dup
