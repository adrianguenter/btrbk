#!/usr/bin/dash
# TODO: ^^^^^^^ Revert to /bin/sh

export POSIXLY_CORRECT=1

set -eu # exit on error, error on unset
[ "${TRACE:=0}" -eq 1 ] && set -x # TRACE=1 btrbk-restore-raw ...

: "${TESTRUN:=0}" # TESTRUN=1 btrbk-restore-raw ...

: "${INPLACE:=0}" # INPLACE=1 btrbk-restore-raw ...

: "${BLOCKSIZE:=$((64 * 1024 * 1024))}" # BLOCKSIZE=$((1024 * 1024 * 1024)) btrbk-restore-raw ...
BLOCKSIZE=$(($BLOCKSIZE + 0))

# Newline character constant (for use in parameter substitution)
NL='
';
# IEC byte multiple constants
KiB=1024; MiB=$((1024 * KiB)); GiB=$((1024 * MiB)); TiB=$((1024 * GiB)); PiB=$((1024 * TiB))
# SI byte multiple constants
 KB=1000;  MB=$((1000 * KB));   GB=$((1000 * MB));   TB=$((1000 * GB));   PB=$((1000 * TB))

# Determine if a string is parseable as a signed integer
_test_parse_int() { ( [ $((${1#+} + 0)) = "${1#+}" ] ) 2>/dev/null; }

# Determine maximum number value and set INTMAX constant
# POSIX specifies only signed long C ints for arithmetic expansion $(())
if _test_parse_int '9223372036854775807'; then
  INTMAX=9223372036854775807 # SInt64
elif _test_parse_int '2147483647'; then
  INTMAX=2147483647 # SInt32
  _errecho "WARNING: This system only supports file sizes <2GB"
else
  _ERR "This system doesn't seem to support signed integers >= 32 bits"
fi


# Add two positive numbers without overflows
_safe_add() {
  [ -n "${1#-*}" ] || _ERR "_safe_add: Operand 1 must be positive"
  [ -n "${2#-*}" ] || _ERR "_safe_add: Operand 2 must be positive"
  # TODO allow for negative (or mixed) operands
  # * If both negative ensure result is not > 0
  # * If mixed ensure result is not > than the positive one
  # Validate operands using test (triggers error on overflow)
  _test_parse_int "$1" || _ERR "_safe_add: Failed parsing operand 1 (overflow?): ${1}"
  _test_parse_int "$2" || _ERR "_safe_add: Failed parsing operand 2 (overflow?): ${2}"
  # Validate result
  [ $(($1 + $2 < 0)) -eq 1 ] && _ERR "_safe_add: Overflow in (${1} + ${2})"
  printf '%d' $(($1 + $2))
}

# "_echo [$string...]" - println to STDOUT, var prefix: "__echo_"
_echo() { [ $# -le 1 ] && { printf '%s\n' "${1-}"; return; }
  __echo_s=; for __echo_i in "$@"; do __echo_s="$__echo_s $__echo_i"; done; printf '%s\n' "$__echo_s"; unset __echo_s __echo_i; }

# "see: _echo" - println to STDERR
_errecho() { >&2 _echo "$@"; }

# "" - do not use, overrides system echo to enforce _echo usage
echo() { _ERR "Use _echo instead of echo"; }

# "_str_contains $haystack $needle" - returns 0 if $needle is contained in $haystack, ex: if _str_contains abc b; ...
_str_contains() { [ -z "$2" ] || [ -n "$1" ] && [ -z "${1##*"${2}"*}" ]; }

# "_str_only $string $chars" - returns 0 if $1 contains only characters found in $2
_str_only() { [ -z "$(printf %s "$1" | tr -d "$2")" ]; }

# "_trap $callback $signal..." - passes $signal as argument 1 to $callback, var prefix: "__trap_", ex: _trap 'echo $1' INT TERM EXIT
_trap() { __trap_cb="$1"; shift; for __trap_s in "$@" ; do trap "$__trap_cb $__trap_s" "$__trap_s"; done; unset __trap_cb __trap_s; }

# "_safe_dqval $value" - prepends backslash, backtick/backquote, dollar-sign, and double-quote in $value with \ and wraps the result in double-quotes for use in eval'd double-quoted strings, ex: eval "echo $(_safe_dqval "\$(date)")"
# WARNING: Do NOT wrap the output of this function in escaped double-quotes at the call site! WRONG: eval "echo \"$(_safe_dqval "\$(date)")\""
_safe_dqval() { [ "${2-}" != QUOTE_ALWAYS ] && set "$1" 'f="%s";if(s~/[[:space:]|&;<>()$`\\"]/)' || set "$1" '';
  printf %s "$1"|awk 'BEGIN{s=""}{gsub(/[\\`$"]/,"\\\\&");if(NR>1){s=s"\n"};s=s$0}END{'"${2-}"'{f="\"%s\""}printf f,s}'; }

# "_safe_eval_setvar $name $value" - validates $name and sanitizes $value using _safe_dquoteval before setting the variable using eval
_safe_eval_setvar() {
  { printf '%s' "$1" | grep -q '[^A-Za-z0-9_]'; } && return 1; eval "$1=$(_safe_dquoteval "$2")"; }

# "_require_bin $command [$pkgname]" - enforces the existence of an executable name in $PATH, var prefix: "__reqbin_", ex: _require_bin btrfs btrfs-progs
_require_bin() { __reqbin_p="$(command -v "$1" ||:)"
  # Ensure that $__reqbin_p is both absolute (starts with "/") and also ends in "/<command_name>" ("/binfile" matches)
  [ "${__reqbin_p%${__reqbin_p#?}}${__reqbin_p#${__reqbin_p%/${1}}}" = "//${1}" ] || _DEPENDENCY_ERR "$1" "$2"; unset __reqbin_p; }

# "_add_cleanup_paths $glob..." - adds paths (globs) to unlink during _CLEANUP, var prefix: "__clnpth_"
_add_cleanup_paths() {
  : "${__file_path_sep:="$(printf '\001')"}"
  for __clnpth_p in "$@"; do
    _str_contains "$__clnpth_p" "$__file_path_sep" && _ERR 'Path contains list separator char'
    __cleanup_paths="${__cleanup_paths-}${__cleanup_paths:+${__file_path_sep}}${__clnpth_p}"
  done; unset __clnpth_p
}

# "_load_info_file $file" - loads K/V pairs from $file into variables named __INFOFILE__${KEY}, var prefix: "__ldinfo_"
_load_info_file() {
  if [ "${1#${1%.info}}"_ != '.info'_ ]; then
    _errecho "WARNING: Expected info (sidecar) file to have an extension of \".info\": ${1}"
  fi
  {
    read -r __ldinfo_v
    case "$__ldinfo_v" in
      '#btrbk-'*) ;;
      *) _ERR "Info (sidecar) file does not start with a #btrbk-v\${VERSION} line: ${1}"
    esac
    while IFS="=" read -r __ldinfo_k __ldinfo_v; do
      case "$__ldinfo_k" in
        '') ;;
        '#'*) ;;
        *) _safe_eval_setvar "__INFOFILE__${__ldinfo_k}" "$__ldinfo_v" || _ERR "Info (sidecar) file has an invalid key: ${1}"
      esac
    done
  } < "$1"; unset __ldinfo_k __ldinfo_v
}

# Outputs a normalized version of a list ("a,f,b,,,c,d,,b,,e,f" => "a,f,b,c,d,e")
_dd_listnorm() { printf '%s' "$1" | awk 'BEGIN{RS=ORS=","} {if($1!=""&&!seen[$1]++){ORS=y;print s;y=",";s=$1}} END{ORS="";print s}'; }
_dd_listadd() { _dd_listhas "$1" "$2" && printf '%s' "$1" || printf '%s%s' "${1:+"${1},"}" "$2"; }
# WARNING: List must be normalized (`list="$(_dd_listnorm "$list")"`) before using _dd_listrem! (Subshell for brevity)
_dd_listrem() { ! _dd_listhas "$1" "$2" && printf '%s' "$1" || ( a="${1#*"${2}"},${1%"${2}"*}"; a="${a##,}"; printf '%s' "${a%%,}" ); }
# Like performing _str_contains but checks comma boundaries to ensure that the search value isn't a substring of another value
_dd_listhas() { [ -n "$1" ] && [ -n "$2" ] && { [ "$1" = "$2" ] || [ -z "${1##*"${2},"*}" ] || [ -z "${1##*",${2}"*}" ]; }; }
_dd() {
  # NOTES:
  # * iflag=fullblock is automatically enabled if count= and/or skip= are used
  # * All numerical values MUST be byte or count integer values
  #   MAGNITUDE SUFFIXES (K, MiB, GB, etc.) ARE UNSUPPORTED!
  # * Default input and output block size values (bs=/ibs=/obs=) are 4096
  # dd always outputs full obs blocks (it will block until it can do so), thus we should leverage that
  # to determine the amount of bytes read by dd's status output of records (we NEVER want a partial!)
  # Partial or zero read can only happen once, then we're done reading (as dd will block until it has an output block to write)
  # This function should just do The Right Thing under any circumstance
  # * if dd doesn't support fullblock we need to synchronize the input of the main dd (dd obs=$size | dd bs=$size ...)
  #  See: https://unix.stackexchange.com/questions/32988/why-does-dd-from-dev-random-give-different-file-sizes/192092#192092
  __dd_ibs=4096
  __dd_obs=4096
  __dd_emu_fullblock=0
  __dd_emu_skipbytes=0
  __dd_emu_countbytes=0
  __dd_emu_seekbytes=0
  # Parse args
  for __dd_a in "$@"; do
    case "$__dd_a" in
      if=*)       __dd_if="${__dd_a#if=}" ;;
      of=*)       __dd_of="${__dd_a#of=}" ;;
      ibs=*)     __dd_ibs="${__dd_a#ibs=}" ;;
      obs=*)     __dd_obs="${__dd_a#obs=}" ;;
      cbs=*)     __dd_cbs="${__dd_a#cbs=}" ;;
      bs=*)       __dd_bs="${__dd_a#bs=}" ;;
      count=*) __dd_count="${__dd_a#count=}" ;;
      skip=*)   __dd_skip="${__dd_a#skip=}" ;;
      seek=*)   __dd_seek="${__dd_a#seek=}" ;;
      conv=*)   __dd_conv="$(_dd_listadd "${__dd_conv-}"  "${__dd_a#conv=}")" ;;
      iflag=*) __dd_iflag="$(_dd_listadd "${__dd_iflag-}" "${__dd_a#iflag=}")" ;;
      oflag=*) __dd_oflag="$(_dd_listadd "${__dd_oflag-}" "${__dd_a#oflag=}")" ;;
      status=*) _ERR "Setting status= value is not supported (use pv instead)" ;;
      *) _ERR "Unsupported dd operand: $__dd_a"
    esac
  done
  # Sanitize and prepare input and output path for eval
  [ -n "${__dd_if:+set}" ] && __dd_if="$(_safe_dqval "$__dd_if")"
  [ -n "${__dd_of:+set}" ] && __dd_of="$(_safe_dqval "$__dd_of")"
  # Validate numerical options
  if [ -n "${__dd_ibs:+set}" ]; then _test_parse_int "$__dd_ibs" || _ERR "Invalid ibs value: $__dd_ibs"; fi
  if [ -n "${__dd_obs:+set}" ]; then _test_parse_int "$__dd_obs" || _ERR "Invalid obs value: $__dd_obs"; fi
  if [ -n "${__dd_bs:+set}" ]; then
    _test_parse_int "$__dd_bs" || _ERR "Invalid bs value: $__dd_bs"
    __dd_ibs=$__dd_bs
    __dd_obs=$__dd_bs
    # CONSIDER: Should we unset __dd_bs here? Is there any issue with using explicit ibs= and obs= based on provided
    # bs= value and using them in every call to dd? Does this cause issues with BusyBox's quirk when ibs == obs?
  fi
  if [ -n "${__dd_count:+set}" ]; then
    _test_parse_int "$__dd_count" || _ERR "Invalid count value: $__dd_count"
    __dd_iflag="$(_dd_listadd "${__dd_iflag-}" fullblock)" # Force fullblock for count=
  fi
  if [ -n "${__dd_skip:+set}" ]; then
    _test_parse_int "$__dd_skip" || _ERR "Invalid skip value: $__dd_skip"
    __dd_iflag="$(_dd_listadd "${__dd_iflag-}" fullblock)" # Force fullblock for skip=
  fi
  if [ -n "${__dd_seek:+set}" ]; then _test_parse_int "$__dd_seek" || _ERR "Invalid seek value: $__dd_seek"; fi
  # Validate and normalize list options (item[,...]) to remove duplicates and null items (,,[,...])
  if [ -n "${__dd_conv:+set}" ]; then
     _str_only "$__dd_conv"  '[[:alpha:]]_,' || _ERR  "conv= contains invalid characters: $__dd_conv"
     __dd_conv="$(_dd_listnorm "$__dd_conv")"
  fi
  if [ -n "${__dd_iflag:+set}" ]; then
    _str_only "$__dd_iflag" '[[:alpha:]]_,' || _ERR "iflag= contains invalid characters: $__dd_iflag"
    __dd_iflag="$(_dd_listnorm "$__dd_iflag")"
    if { _dd_listhas "$__dd_iflag" fullblock && [ $DD_IFLAG_FULLBLOCK -ne 1 ]; }; then
      __dd_iflag="$(_dd_listrem "$__dd_iflag" fullblock)"
      __dd_emu_fullblock=1
    fi
    if { _dd_listhas "$__dd_iflag" count_bytes && [ $DD_IFLAG_COUNTBYTES -ne 1 ]; }; then
      __dd_iflag="$(_dd_listrem "$__dd_iflag" count_bytes)"
      # Only enable emulation if actually needed (count is set and > 0)
      [ ${__dd_count:-0} -gt 0 ] && __dd_emu_countbytes=1
    fi
    if { _dd_listhas "$__dd_iflag" skip_bytes && [ $DD_IFLAG_SKIPBYTES -ne 1 ]; }; then
      __dd_iflag="$(_dd_listrem "$__dd_iflag" skip_bytes)"
      # Only enable emulation if actually needed (skip is set and > 0)
      [ ${__dd_skip:-0} -gt 0 ] && __dd_emu_skipbytes=1
    fi
  fi
  if [ -n "${__dd_oflag:+set}" ]; then
     _str_only "$__dd_oflag" '[[:alpha:]]_,' || _ERR "oflag= contains invalid characters: $__dd_oflag"
     __dd_oflag="$(_dd_listnorm "$__dd_oflag")"
    if { _dd_listhas "$__dd_oflag" seek_bytes && [ $DD_OFLAG_SEEKBYTES -ne 1 ]; }; then
      __dd_oflag="$(_dd_listrem "$__dd_oflag" seek_bytes)"
      # Only enable emulation if actually needed (seek is set and > 0)
      [ ${__dd_seek:-0} -gt 0 ] && __dd_emu_seekbytes=1
    fi
  fi
  # NOTE: All lists (conv,iflag,oflag) are safe to traverse and eval unquoted below this point as
  # they're checked with _str_only above
  __cmd=
  __cmd_end=
  if [ $__dd_emu_fullblock -eq 1 ]; then
    _errecho "WARNING: Emulating GNU dd iflag: fullblock"
    __dd_a=
    __dd_in_conv=
    if [ -n "${__dd_conv:+set}" ]; then
      # Remove input-related conv options from list and add to a separate list
      for __dd_a in $(printf %s\\n "$__dd_conv" | tr , \\n); do
        if ! _dd_listhas excl,nocreat,notrunc,fdatasync,fsync "$__dd_a"; then
          __dd_conv="$(_dd_listrem "$__dd_conv" $__dd_a)"
          __dd_in_conv="$(_dd_listadd "${__dd_in_conv-}" $__dd_a)"
        fi
      done
    fi
    # TODO: Allow user to specify this value (add a dedicated operand? unbufd_ibs= or similar?)
    __dd_emu_unbufd_ibs=$(($__dd_ibs / 2 ))
    [ $__dd_emu_unbufd_ibs -lt 1 ] && __dd_emu_unbufd_ibs=1
    __cmd="${__cmd}dd status=none ibs=${__dd_emu_unbufd_ibs}${__dd_iflag:+ iflag="$__dd_iflag"}"
    __cmd="${__cmd}${__dd_if:+ if="$__dd_if"}"
    __cmd="${__cmd}${__dd_cbs:+ cbs="$__dd_cbs"}${__dd_in_conv:+ conv="$__dd_in_conv"}"
    __cmd="${__cmd} obs=${__dd_ibs} | "
    unset __dd_if __dd_cbs
  fi
  # $__dd_seek is > 0 if $__dd_emu_seekbytes is enabled
  # Seek remainder
  __cmd_seek=
  if [ $__dd_emu_seekbytes -eq 1 ]; then
    _errecho "WARNING: Emulating GNU dd oflag: seek_bytes"
    if [ $(($__dd_seek % $__dd_obs)) -gt 0 ]; then
      __cmd_seek="dd count=0${__dd_conv:+ conv="$__dd_conv"} seek=1 obs=$(($__dd_seek % $__dd_obs))"
      __cmd_seek="${__cmd_seek}${__dd_oflag:+ oflag="$__dd_oflag"} & seekpid=\$!; "
    fi
    __dd_seek=$(($__dd_seek / $__dd_obs))
  fi
  # $__dd_skip is > 0 if $__dd_emu_skipbytes is enabled
  # Skip remainder
  __cmd_skip=
  if [ $__dd_emu_skipbytes -eq 1 ]; then
    _errecho "WARNING: Emulating GNU dd iflag: skip_bytes"
    if [ $(($__dd_skip % $__dd_ibs)) -gt 0 ]; then
      __cmd_skip="dd ibs=$(($__dd_skip % $__dd_ibs))${__dd_iflag:+ iflag="$__dd_iflag"} skip=1 count=0 && "
    fi
    __dd_skip=$(($__dd_skip / $__dd_ibs))
  fi
  # $__dd_count is > 0 if $__dd_emu_countbytes is enabled
  # Write remainder
  __cmd_count=
  if [ $__dd_emu_countbytes -eq 1 ]; then
    _errecho "WARNING: Emulating GNU dd iflag: count_bytes"
    if [ $(($__dd_count % $__dd_ibs)) -gt 0 ]; then
      __cmd_count=" && dd ibs=$(($__dd_count % $__dd_ibs))${__dd_iflag:+ iflag="$__dd_iflag"} count=1"
      __cmd_count="${__cmd_count}${__dd_cbs:+ cbs="$__dd_cbs"}${__dd_conv:+ conv="$__dd_conv"}"
    fi
    __dd_count=$(($__dd_count / $__dd_ibs))
  fi
  # Assemble command
  if [ -n "$__cmd_skip$__cmd_count$__cmd_seek" ]; then
    __cmd="${__cmd}{ "
    __cmd_end="; }${__dd_if:+ <"$__dd_if"}${__dd_of:+ >"$__dd_of"}${__cmd_end}"
    unset __dd_if __dd_of
  fi
  __cmd="${__cmd}${__cmd_seek}${__cmd_skip}${__cmd_seek:+"wait \"\$seekpid\" && "}"
  __cmd="${__cmd}dd ibs=${__dd_ibs}${__dd_iflag:+ iflag="$__dd_iflag"}${__dd_if:+ if="$__dd_if"}"
  __cmd="${__cmd}${__dd_skip:+ skip="$__dd_skip"}${__dd_count:+ count="$__dd_count"}${__dd_seek:+ seek="$__dd_seek"}"
  __cmd="${__cmd}${__dd_cbs:+ cbs="$__dd_cbs"}${__dd_conv:+ conv="$__dd_conv"}"
  __cmd="${__cmd} obs=${__dd_obs}${__dd_oflag:+ oflag="$__dd_oflag"}${__dd_of:+ of="$__dd_of"}"
  __cmd="${__cmd}${__cmd_count}${__cmd_end}"

  _errecho "$ $__cmd"

  # TODO: eval

  # TODO? error handling
}

_test_source() {
  # Verifies the beginning and end of the stream
  __tstsrc_total_bytes=$(($2 + 0))
  __SENDSTREAM__subvolname=
  _reconstruct_source "$1" "$2" "$3" $((1024 * 1024)) 0 | {
    # NOTE: The send stream stores number values as little-endian (0x3c, 0x00 is decimal value 60, not 15360)
    # Thus we can manipulate them as number strings using od and and other tools, as they will terminate reading
    # on the first 0x00 (null) byte
    # See: https://btrfs.wiki.kernel.org/index.php/Design_notes_on_Send/Receive

    # send stream header: 17 bytes
    dd status=none bs=1 count=13 | grep -q ^btrfs-stream         || _ERR "bad magic value" # magic "btrfs-stream\0"
    dd status=none bs=1 count=4  | grep -q ^"$(printf '\001')"\$ || _ERR "stream version != 0x01" # stream version

    # send command header: 10 bytes
    dd status=none bs=1 skip=4 count=0 # command size; unneeded as the only info we want is in TLV1
    # Expect and validate a "Send subvolume or snapshot" command (0x01 or 0x02)
    __tstsrc_cmdtype=$(($(dd status=none bs=1 count=2 | od -An -vtu2) + 0)) # command type
    [ $__tstsrc_cmdtype -eq 1 ] || [ $__tstsrc_cmdtype -eq 2 ] || _ERR "command type != 0x01|0x02 "
    # NOTE: We don't perform a CRC32 check here as we have no easy way of getting the bytes to checksum (they contain 0x0 anyway!)
    dd status=none bs=1 skip=4 count=0 # CRC32

    # send TLV1 (name) header: 4 bytes
    dd status=none bs=1 count=2 | grep -q ^"$(printf '\017')"\$ || _ERR "TLV1 type != 0x0f"
    __tstsrc_subvolname_size=$(($(dd status=none bs=1 count=2 | od -An -vtu2) + 0))

    # send TLV1 (name) payload: $subvolname_size bytes
    __SENDSTREAM__subvolname="$(dd status=none bs=1 count=$__tstsrc_subvolname_size)"

    # skip to end - 6 bytes (send end command)
    # TODO? Skip this check altogether and WARN if $__total_bytes is over $4 and fullblock or skip_bytes is unavailable
    dd status=none bs=1M iflag=fullblock,skip_bytes skip=$(($__tstsrc_total_bytes - 6 - $__tstsrc_subvolname_size - 31)) count=0
    dd status=none bs=1 count=2 | grep -q ^"$(printf '\025')"\$ || _ERR "send end fail"
    dd status=none bs=1 count=4 | grep -q ^"$(printf '\120\154\311\235')"\$ || _ERR "send end fail"
  }
  unset __tstsrc_total_bytes __tstsrc_subvolname_size __tstsrc_cmdtype
}

_reconstruct_source() {
  __source_list="$1"
  __total_bytes=$(($2 + 0))
  __toolchain="${3-}"
  __block_size=$((${4:-BLOCKSIZE} + 0))
  __source_destroy="${5:-0}"

  # TODO Does this belong here or below in main? (Prob. the latter)
  if [ "$INPLACE" -eq 1 ]; then
    # TODO ASK FOR CONFIRMATION!
    _errecho "WARNING: Disabling SIGINT (Ctrl-c) for destructive operation!"
    trap - INT
  fi

  __read_bytes=0
  __remaining_bytes="$__total_bytes"
  for __f in $__source_list; do
    __f_size="$(stat -c%s "$__f")"
    __f_remaining_bytes="$__f_size"
    __f_pos=0
    __dd_bytes="$__block_size"
    while : ; do
      [ $__remaining_bytes -gt 0 ] || break
      [ $__f_remaining_bytes -gt 0 ] || break

      [ $__dd_bytes -le $__remaining_bytes ] || __dd_bytes=$__remaining_bytes
      [ $__dd_bytes -le $__f_remaining_bytes ] || __dd_bytes=$__f_remaining_bytes


      # TODO? Use dd without unportable options and WARN if fullblock, skip_bytes, or count_bytes is unavailable
      # This would require parsing dd's status output to determine the number of bytes read
      # _errecho "Read from: $__rpos"
      dd status=none if="$__f" bs=1M skip="$__f_pos" count="$__dd_bytes" iflag=fullblock,skip_bytes,count_bytes

      __f_pos=$(($__f_pos + $__dd_bytes))
      __f_remaining_bytes=$(($__f_remaining_bytes - $__dd_bytes))
      __read_bytes=$(($__read_bytes + $__dd_bytes))
      __remaining_bytes=$(($__remaining_bytes - $__dd_bytes))

      # TODO fallocate
      # _errecho "fallocate"
      #fallocate --keep-size --punch-hole --offset $readpos --length $readsize $infile >&2 &
    done
    #_errecho "FILE DONE: ${__f}"
  done
  #_errecho "READ DONE"
}

_USAGE() {
  >&2 printf \
'usage: [TESTRUN=1] [BLOCKSIZE=<bytes>] [INPLACE=1] [TRACE=1] %s <info-file> <target-subvol>

Environment variables:

TESTRUN=1  Perform a test run of BLOCKSIZE bytes (disables INPLACE)

BLOCKSIZE=<bytes>  Set the amount of bytes read (and truncated, if INPLACE) at a time
                   Note that shell arithmetic $((...)) can be used to calculate values, for example
                   BLOCKSIZE=$((64 * 1024 * 1024)) sets the value to 67108864 (64MiB), the default

INPLACE=1  Truncate the head of the source raw backup file (fallocate --punch-hole) as its read;
           a mandatory test run will automatically be performed and must complete successfully
           === WARNING ===
           THIS OPTION DESTROYS THE RAW BACKUP SOURCE FILE -- ENSURE THAT YOU HAVE ANOTHER COPY
           OF THE SNAPSHOT OR CAN AFFORD TO LOSE THE DATA BEFORE ENABLING THIS OPTION!
           If the restore operation fails for any reason the file will be PERMANENTLY CORRUPTED,
           so only use if absolutely necessary; e.g. the backup file and target are on the same
           btrfs filesystem and the space used by the file is needed to restore the subvolume

TRACE=1    Enable shell trace output

' "$(basename "${0}")"
  exit 1
}

_ERR() {
  _errecho "ERROR: ${1}"
  [ "${2:-0}" -eq 1 ] && { _errecho; USAGE; }
  exit "${3:-1}"
}

_DEPENDENCY_ERR() {
  >&2 printf 'ERROR: "%s" not found in $PATH%s\n' "$1" "${2:+"; is the \"${2}\" package (or equivalent) installed?"}"
  exit 9
}

_CLEANUP() ( # VAR PREFIX: __clnup_
  set +e
  __clnup_l="${__clnup_paths-}"; while [ "$__clnup_l" != "${__clnup_l2-}" ]; do
    __clnup_l="${__clnup_l2:-${__clnup_l}}"
    __clnup_l2="${__clnup_l%${__file_path_sep}*}"
    __clnup_v="${__clnup_l#${__clnup_l2}${__file_path_sep}}"
    rm "$__clnup_v"
  done; unset __clnup_l __clnup_l2 __clnup_v
)

_SHUTDOWN() {
  [ "${__shutdown_bypass-0}" -eq 1 ] && return
  __shutdown_bypass=1
  case "${1-}" in
    INT|TERM) trap - INT TERM;;
    EXIT) : ;;
    *) _ERR "Invalid shutdown signal: $1" 0 127
  esac
  _echo "==> SHUTDOWN: $1"
  _CLEANUP
}

_MAIN() {
  _trap _SHUTDOWN INT TERM EXIT

  # Required dependencies
  _require_bin awk      awk
  _require_bin grep     grep
  _require_bin sed      sed # TODO Replace all sed with awk
  _require_bin btrfs    btrfs-progs
  _require_bin basename coreutils
  _require_bin dirname  coreutils
  _require_bin dd       coreutils
  _require_bin od       coreutils
  _require_bin readlink coreutils
  _require_bin stat     coreutils

  # Feature-test dd
  DD_IFLAG_FULLBLOCK=0
  DD_IFLAG_SKIPBYTES=0
  DD_IFLAG_COUNTBYTES=0
  DD_OFLAG_SEEKBYTES=0
  dd_helptxt="$(dd --help 2>&1)" \
  || dd_helptxt="$(dd -h 2>&1)" \
  || _ERR "Failed to parse help text for dd"
  _str_contains "$dd_helptxt" fullblock   && DD_IFLAG_FULLBLOCK=1
  _str_contains "$dd_helptxt" skip_bytes  && DD_IFLAG_SKIPBYTES=1
  _str_contains "$dd_helptxt" count_bytes && DD_IFLAG_COUNTBYTES=1
  _str_contains "$dd_helptxt" seek_bytes  && DD_OFLAG_SEEKBYTES=1

  if [ "$INPLACE" -eq 1 ]; then
    _require_bin fallocate  util-linux
    _require_bin findmnt    util-linux

    # Feature-test fallocate
    falloc_punch_hole=
    falloc_helptxt="$(fallocate --help 2>&1)" \
    || falloc_helptxt="$(fallocate -h 2>&1)" \
    || _ERR "Failed to parse help text for fallocate"
    _str_contains "$falloc_helptxt" --punch-hole && falloc_punch_hole=' --punch-hole'

    # TODO Feature-test findmnt
  fi
total=$((1024 * 1024 * 1024 + 124283))
#dd status=none ibs=3 obs=7 if=/dev/random
DD_BLOCKFACTOR=1
# Full emu
DD_IFLAG_FULLBLOCK=${FULLBLK:-1}
DD_IFLAG_SKIPBYTES=${SKIP:-1}
DD_IFLAG_COUNTBYTES=${COUNT:-1}
DD_OFLAG_SEEKBYTES=${SEEK:-1}
_dd "$@" | pv -bn >/dev/null
exit

  # Script arguments
  source_info="${1-}"
  target="${2-}"

  # Source check
  if [ -z "$source_info" ]; then
    _ERR "Info (sidecar) file was not specified" 1
  elif ! [ -r "$source_info" ]; then
    _ERR "Info (sidecar) file doesn't exist or isn't readable: ${source_info}"
  fi

  source_dir="$(dirname "$(readlink -f "$source_info")")"
  source_info="${source_dir}/${source_info##*/}" # Canonicalize
  _load_info_file "$source_info"
  source_name="${__INFOFILE__FILE##*/}"
  subvol_name="${source_name%.btrfs*}"
  source="${source_dir}/${source_name}"

  if [ "${__INFOFILE__INCOMPLETE-0}" -eq 1 ]; then
    _ERR "Raw backup file is marked incomplete"
  fi

  if [ -n "${__INFOFILE__split+x}" ]; then
    source_glob="${source}.split_*"
  fi

  file_list=${source_glob:-$source}

  # Source sanity checks and preliminary info gathering
  toolchain=
  total_size=0
  for f in $file_list; do
    # Attempt capturing the filesystem name which houses the source file(s) to test for fallocate --punch-hole compat
    [ "$INPLACE" -eq 1 ] && "${source_fs:="$(findmnt -n -o FSTYPE --target "$f")"}"
    [ -r "$f" ] || _ERR "File doesn't exist or isn't readable: ${f}"
    fsize="$(stat -c%s "$f")"
    [ "$fsize" -gt 0 ] || _ERR "Source file appears empty (stat reported 0 bytes or errored): ${f}"
    total_size=$(($total_size + $fsize))
  done

  # $do_test_source && ...
  _test_source "$file_list" $total_size "$toolchain" || _ERR "Source test failed"

  _echo "NAME FROM STREAM: $__SENDSTREAM__subvolname" # Wait, what?
  [ -n "${__SENDSTREAM__subvolname-}" ] && subvolname="$__SENDSTREAM__subvolname"

  # Target sanity checks
  if [ -e "${target}/${subvol_name}" ]; then
    _ERR "Restore target exists, aborting: ${target}/${subvol_name}"
  fi

  set +e; target_info="$(btrfs subvolume show "$target")"; set -e
  [ $? -eq 0 ] || target_info=

  if [ -z "$target_info" ]; then
    _ERR "Restore target does not appear to be a btrfs subvolume (\"btrfs sub show '${target}'\" failed)"
  fi

  if printf '%s' "$target_info" | grep Flags: | grep -q readonly; then
    _ERR "Restore target appears to be readonly: ${target}"
  fi

  # Main
  _reconstruct_source "$file_list" $total_size "$toolchain" "$BLOCKSIZE" 0 \
  | btrfs receive -v "$target" #; _echo ">>>${?}" # "$target"

  exit 0
}

_MAIN "$@"

##### TODO
# * Build $toolchain pipeline string and eval it safely in _reconstruct_source
# * TESTRUN: make sure key can decrypt, or passphrase is correct, all utilities work, etc before INPLACE destructive read
# * ? unencrypt
#   - openssl
#     - keyfile
#     - kdf
#   - gpg
# * ? uncompress
#   - xz
#   - gzip
