#!/usr/bin/dash
# TODO: ^^^^^^^ Revert to /bin/sh

set -eu # exit on error, error on unset
[ "${TRACE:=0}" -eq 1 ] && set -x # TRACE=1 btrbk-restore-raw ...

: "${INPLACE:=0}" # INPLACE=1 btrbk-restore-raw ...

: "${BUFFER_SIZE:=$((64 * 1024 * 1024))}" # BUFFER_SIZE=$((1024 * 1024 * 1024)) btrbk-restore-raw ...

_str_contains() { [ -n "$1" ] && [ -z "${1##*$2*}" ] || [ -z "$2" ] ; }
_trap() { __cb="$1"; shift; for __s in "$@" ; do trap "$__cb $__s" "$__s"; done; unset __cb __s ; }

_USAGE() {
  >&2 echo "usage: [INPLACE=1|0] [TRACE=1|0] $(basename "${0}") <info-file> <dest-subvol>\n"
  >&2 echo "Environment variables:"
  >&2 echo "\nINPLACE  1: Incrementally truncate the head of the source file (fallocate --punch-hole) as its read"
  >&2 echo "            === WARNING ==="
  >&2 echo "            THIS OPTION DESTROYS THE RAW BACKUP SOURCE FILE"
  >&2 echo "            If the restore operation fails for any reason the file will be PERMANENTLY CORRUPTED!"
  >&2 echo "            Only use this if absolutely necessary -- e.g., source and target are on the same filesystem"
  >&2 echo "            and space is at a premium. ENSURE THAT YOU HAVE ANOTHER COPY OF THIS BACKUP OR CAN AFFORD TO"
  >&2 echo "            LOSE THE DATA! YOU HAVE BEEN WARNED"
  >&2 echo "         0: (Default) Do not modify the raw backup source file"
  >&2 echo "\nTRACE    1: Print shell trace output"
  >&2 echo "         0: (Default) Disable shell trace output"
  exit 1
}

_ERR() {
  >&2 echo "ERROR: ${1}"
  [ "${2:-0}" -eq 1 ] && { echo; _USAGE; }
  exit "${3:-1}"
}

_DEPENDENCY_ERR() {
  >&2 printf 'ERROR: "%s" not found in $PATH%s\n' "$1" "${2:+"; is the \"${2}\" package (or equivalent) installed?"}"
  exit 9
}

_CLEANUP() (
  set +e
  __l="${__cleanup_paths-}"; while [ "$__l" != "${__l2-}" ]; do
    __l="${__l2:-${__l}}"; __l2="${__l%${__file_path_sep}*}"
    __v="${__l#${__l2}${__file_path_sep}}"
    rm "$__v"
  done; unset __l __l2 __v
)

_SHUTDOWN() {
  [ "${__shutdown_bypass-0}" -eq 1 ] && return
  __shutdown_bypass=1
  case "${1-}" in
    INT|TERM) trap - INT TERM;;
    EXIT) : ;;
    *) _ERR "Invalid shutdown signal: $1" 0 127
  esac
  echo "==> SHUTDOWN: $1"
  _CLEANUP
}

_add_cleanup_paths() {
  : "${__file_path_sep:="$(printf '\001')"}"
  for __p in "$@"; do
    _str_contains "$__p" "$__file_path_sep" && _ERR 'Path contains list separator char'
    __cleanup_paths="${__cleanup_paths-}${__cleanup_paths:+${__file_path_sep}}${__p}"
  done; unset __p
}

_load_info_file() {
  # Reads a raw backup sidecar file into the current environment with a var (key) prefix of __INFOFILE__
  {
    read -r __v; case "$__v" in
      '#btrbk-'*) ;;
      *) _ERR "Info (sidecar) file does not start with a #btrbk-v\${VERSION} line"
    esac
    while IFS="=" read -r __k __v; do
      case "$__k" in
        '') ;;
        '#'*) ;;
        *) eval "__INFOFILE__${__k}='${__v}'"
      esac
    done
  } < "$1"; unset __k __v
}

_require_bin() { __p="$(command -v "$1" ||:)"; eval alias "${1}='${__p}'"; [ -n "$__p" ] || _DEPENDENCY_ERR "$1" "$2"; unset __p; }

_trap _SHUTDOWN INT TERM EXIT

# Required dependencies
_require_bin btrfs    btrfs-progs
_require_bin basename coreutils
_require_bin dirname  coreutils
_require_bin dd       coreutils
_require_bin mkfifo   coreutils
_require_bin readlink coreutils
_require_bin stat     coreutils
if [ "$INPLACE" -eq 1 ]; then
  _require_bin findmnt  util-linux
fi

# Script arguments
source_info="${1-}"
destination="${2-}"

# Source check
if [ -z "$source_info" ]; then
  _ERR "Info (sidecar) file was not specified" 1
elif ! [ -r "$source_info" ]; then
  _ERR "Info (sidecar) file doesn't exist or isn't readable: ${source_info}"
fi

source_dir="$(dirname "$(readlink -f "$source_info")")"

source_info="${source_dir}/${source_info##*/}" # Canonicalize

_load_info_file "$source_info"

source="${source_dir}/${__INFOFILE__FILE##*/}"

if [ "${__INFOFILE__INCOMPLETE-0}" -eq 1 ]; then
  _ERR "Raw backup file is marked incomplete"
fi

if [ -n "${__INFOFILE__split+x}" ]; then
  source_glob="${source}.split_*"
# .split_
fi

file_list=${source_glob:-$source}

# Source sanity checks and preliminary info gathering
total_size=0
for f in $file_list; do
  # Attempt capturing the filesystem name which houses the source file(s) to test for fallocate --punch-hole compat
  [ "$INPLACE" -eq 1 ] && "${source_fs:="$(findmnt -n -o FSTYPE --target "$f")"}"
  [ -r "$f" ] || _ERR "File doesn't exist or isn't readable: ${f}"
  fsize="$(stat -c%s "$f")"
  [ "$fsize" -gt 0 ] || _ERR "Source file appears empty (size is 0 bytes): ${f}"
  total_size=$(($total_size + $fsize))
done

# Destination sanity checks
echo "$destination"

# Main
fifo="${source}.fifo~${$}"
mkfifo -m 0600 "$fifo"
_add_cleanup_paths "$fifo"

if [ "$INPLACE" -eq 1 ]; then
  # TODO ASK FOR CONFIRMATION!
  >&2 echo "WARNING: Disabling SIGINT (Ctrl-c) for destructive operation!"
  trap - INT
fi

exec 3<> "$fifo"
{
  for f in $file_list; do
    readpos=0
    fsize="$(stat -c%s "$f")"
    while : ; do
      #echo "Read from: $readpos"
      dd status=none if=$f bs=1M skip=$readpos count=$BUFFER_SIZE iflag=count_bytes,skip_bytes >"$fifo"
      #echo "fallocate"
      #fallocate --keep-size --punch-hole --offset $readpos --length $readsize $infile >&2 &
      readpos=$(($readpos + $BUFFER_SIZE))
      [ $readpos -lt $fsize ] || { >&2 echo "DONE: ${f}"; break; }
    done; sleep 1
  done
} & read_pid=$!

#outfile=/tmp/btrbk-restore.out # TODO Remove
#dd status=none bs=1M count="$total_size" iflag=count_bytes of="$outfile" <"$fifo" & write_pid=$!

# Need dd here or btrfs receive blocks forever at end like dd does without count (how to fix this fifo EOF issue?)
< "$fifo" dd status=none bs=1M count="$total_size" iflag=count_bytes | btrfs receive -v "$destination" & write_pid=$!

wait $read_pid $write_pid

exit

##### MAIN BODY SEQ
# * ? unsplit DONE
#   - loop split files for easy truncation (recalc filesize for each)
# * ? unencrypt
#   - openssl
#     - keyfile
#     - kdf
#   - gpg
# * ? uncompress
#   - xz
#   - gzip

# FIFO usage w/ dd:
# dd if=/dev/zero bs=1M count=1024 >$fifo &
# dd of=/dev/null <$fifo
