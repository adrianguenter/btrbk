#!/usr/bin/dash
# TODO: ^^^^^^^ Revert to /bin/sh

export POSIXLY_CORRECT=1

set -eu # exit on error, error on unset
[ "${TRACE:=0}" -eq 1 ] && set -x # TRACE=1 btrbk-restore-raw ...

: "${TESTRUN:=0}" # TESTRUN=1 btrbk-restore-raw ...

: "${INPLACE:=0}" # INPLACE=1 btrbk-restore-raw ...

: "${BLOCKSIZE:=$((64 * 1024 * 1024))}" # BLOCKSIZE=$((1024 * 1024 * 1024)) btrbk-restore-raw ...
BLOCKSIZE=$(($BLOCKSIZE + 0))

# Newline character constant (for use in parameter substitution)
NL='
';
# IEC byte multiple constants
KiB=1024; MiB=$((1024 * KiB)); GiB=$((1024 * MiB)); TiB=$((1024 * GiB)); PiB=$((1024 * TiB))
# SI byte multiple constants
 KB=1000;  MB=$((1000 * KB));   GB=$((1000 * MB));   TB=$((1000 * GB));   PB=$((1000 * TB))

# Determine if a string is parseable as an signed integer
_test_parse_int() { ( [ $((${1#+} + 0)) = "${1#+}" ] ) 2>/dev/null; }
# Determine maximum number value and set INTMAX constant
# POSIX specifies only signed long C ints for arithmetic expansion $(())
if _test_parse_int '9223372036854775807'; then
  INTMAX=9223372036854775807 # SInt64
elif _test_parse_int '2147483647'; then
  INTMAX=2147483647 # SInt32
  _errecho "WARNING: This system only supports file sizes <2GB"
else
  _ERR "This system doesn't seem to support signed integers >= 32 bits"
fi


# Add two positive numbers without overflows
_safe_add() {
  [ -n "${1#-*}" ] || _ERR "_safe_add: Operand 1 must be positive"
  [ -n "${2#-*}" ] || _ERR "_safe_add: Operand 2 must be positive"
  # TODO allow for negative (or mixed) operands
  # * If both negative ensure result is not > 0
  # * If mixed ensure result is not > than the positive one
  # Validate operands using test (triggers error on overflow)
  _test_parse_int "$1" || _ERR "_safe_add: Failed parsing operand 1 (overflow?): ${1}"
  _test_parse_int "$2" || _ERR "_safe_add: Failed parsing operand 2 (overflow?): ${2}"
  # Validate result
  [ $(($1 + $2 < 0)) -eq 1 ] && _ERR "_safe_add: Overflow in (${1} + ${2})"
  printf '%d' $(($1 + $2))
}

# "_echo [$string...]" - println to STDOUT, var prefix: "__echo_"
_echo() { [ $# -le 1 ] && { printf '%s\n' "${1-}"; return; }
  __echo_s=; for __echo_i in "$@"; do __echo_s="$__echo_s $__echo_i"; done; printf '%s\n' "$__echo_s"; unset __echo_s __echo_i; }

# "see: _echo" - println to STDERR
_errecho() { >&2 _echo "$@"; }

# "" - do not use, overrides system echo to enforce _echo usage
echo() { _ERR "Use _echo instead of echo"; }

# "_str_contains $haystack $needle" - returns 0 if $needle is contained in $haystack, ex: if _str_contains abc b; ...
_str_contains() { [ -z "$2" ] || [ -n "$1" ] && [ -z "${1##*"${2}"*}" ]; }

# "_trap $callback $signal..." - passes $signal as argument 1 to $callback, var prefix: "__trap_", ex: _trap 'echo $1' INT TERM EXIT
_trap() { __trap_cb="$1"; shift; for __trap_s in "$@" ; do trap "$__trap_cb $__trap_s" "$__trap_s"; done; unset __trap_cb __trap_s; }

# "_safe_dquoteval $value" - prepends backslash, backtick/backquote, dollar-sign, and double-quote in $value with \ and wraps the result in double-quotes for use in eval'd double-quoted strings, ex: eval "echo $(_safe_dquoteval "\$(date)")"
# WARNING: Do NOT wrap the output of this function in escaped double-quotes at the call site! WRONG: eval "echo \"$(_safe_dquoteval "\$(date)")\""
_safe_dquoteval() {  printf '"'; printf '%s' "$1" | sed 's/[\\`$"]/\\&/g'; printf '"'; }

# "_safe_eval_setvar $name $value" - validates $name and sanitizes $value using _safe_dquoteval before setting the variable using eval
_safe_eval_setvar() {
  { printf '%s' "$1" | grep -q '[^A-Za-z0-9_]'; } && return 1; eval "${1}=$(_safe_dquoteval "$2")"; }

# "_require_bin $command [$pkgname]" - enforces the existence of an executable name in $PATH, var prefix: "__reqbin_", ex: _require_bin btrfs btrfs-progs
_require_bin() { __reqbin_p="$(command -v "$1" ||:)"
  # Ensure that $__reqbin_p is both absolute (starts with "/") and also ends in "/<command_name>" ("/binfile" matches)
  [ "${__reqbin_p%${__reqbin_p#?}}${__reqbin_p#${__reqbin_p%/${1}}}" = "//${1}" ] || _DEPENDENCY_ERR "$1" "$2"; unset __reqbin_p; }

# "_add_cleanup_paths $glob..." - adds paths (globs) to unlink during _CLEANUP, var prefix: "__clnpth_"
_add_cleanup_paths() {
  : "${__file_path_sep:="$(printf '\001')"}"
  for __clnpth_p in "$@"; do
    _str_contains "$__clnpth_p" "$__file_path_sep" && _ERR 'Path contains list separator char'
    __cleanup_paths="${__cleanup_paths-}${__cleanup_paths:+${__file_path_sep}}${__clnpth_p}"
  done; unset __clnpth_p
}

# "_load_info_file $file" - loads K/V pairs from $file into variables named __INFOFILE__${KEY}, var prefix: "__ldinfo_"
_load_info_file() {
  if [ "${1#${1%.info}}"_ != '.info'_ ]; then
    _errecho "WARNING: Expected info (sidecar) file to have an extension of \".info\": ${1}"
  fi
  {
    read -r __ldinfo_v
    case "$__ldinfo_v" in
      '#btrbk-'*) ;;
      *) _ERR "Info (sidecar) file does not start with a #btrbk-v\${VERSION} line: ${1}"
    esac
    while IFS="=" read -r __ldinfo_k __ldinfo_v; do
      case "$__ldinfo_k" in
        '') ;;
        '#'*) ;;
        *) _safe_eval_setvar "__INFOFILE__${__ldinfo_k}" "$__ldinfo_v" || _ERR "Info (sidecar) file has an invalid key: ${1}"
      esac
    done
  } < "$1"; unset __ldinfo_k __ldinfo_v
}

#DD_BLOCKFACTOR=32 let user specify as we enforce the middle buffer later
_dd_listnorm() { printf '%s' "$1" | awk 'BEGIN{RS=ORS=","} $0!="" && !seen[$0]++'; }
# awk 'BEGIN{RS=ORS=",";y=""} {if ($1!=""&&!seen[$1]++) {ORS=y;print s;y=";";s=$0}} END{ORS="";print s}' # No trailing comma
_dd_listadd() { printf '%s%s' "${1:+"${1},"}" "$2"; }
_dd_listrem() { __ddlrem_a="${1#*"${2}"},${1%"${2}"*}"; __ddlrem_a="${__ddlrem_a##,}"; printf '%s' "${__ddlrem_a%%,}"; unset __ddlrem_a; }
# Like performing _str_contains but checks comma boundaries to ensure that the search value isn't a substring of another value
_dd_listhas() { [ -n "$1" ] && [ -n "$2" ] && { [ "$1" = "$2" ] || [ -z "${1##*"${2},"*}" ] || [ -z "${1##*"${2},"*}" ]; }; }
_dd() {
  # dd always outputs full obs blocks (it will block until it can do so), thus we should leverage that
  # to determine the amount of bytes read by dd's status output of records (we NEVER want a partial!)
  # Partial or zero read can only happen once, then we're done reading (as dd will block until it has an output block to write)
  # This function should just do The Right Thing under any circumstance
  # * if dd doesn't support fullblock we need to synchronize the input of the main dd (dd obs=$size | dd bs=$size ...)
  #  See: https://unix.stackexchange.com/questions/32988/why-does-dd-from-dev-random-give-different-file-sizes/192092#192092

  __dd_emu_fullblock=0
  __dd_emu_skipbytes=0
  __dd_emu_countbytes=0
  # Parse args
  for __dd_a in "$@"; do
    _errecho ">>$__dd_a"
    # TODO Check dd help text for existence of option or err
    case "$__dd_a" in
      if=*)       __dd_if="${__dd_a#if=}" ;;
      of=*)       __dd_of="${__dd_a#of=}" ;;
      ibs=*)     __dd_ibs="${__dd_a#ibs=}" ;;
      obs=*)     __dd_obs="${__dd_a#obs=}" ;;
      bs=*)       __dd_bs="${__dd_a#bs=}" ;;
      count=*) __dd_count="${__dd_a#count=}" ;;
      skip=*)   __dd_skip="${__dd_a#skip=}" ;;
      seek=*)   __dd_seek="${__dd_a#seek=}" ;;
      conv=*)   __dd_conv="$(_dd_listadd "${__dd_conv-}"  "${__dd_a#conv=}")" ;;
      iflag=*) __dd_iflag="$(_dd_listadd "${__dd_iflag-}" "${__dd_a#iflag=}")" ;;
      oflag=*) __dd_oflag="$(_dd_listadd "${__dd_oflag-}" "${__dd_a#oflag=}")" ;;
      status=*) _ERR "Setting status= value is not supported (use pv instead)" ;;
      *) _ERR "Unsupported dd arg: $__dd_a"
    esac
  done

  # Validate size options (NOTE: all must be byte|count values, no suffixes!)
  [ -n "${__dd_ibs:+isset}" ]   && _test_parse_int "$__dd_ibs"
  [ -n "${__dd_obs:+isset}" ]   && _test_parse_int "$__dd_obs"
  [ -n "${__dd_bs:+isset}" ]    && _test_parse_int "$__dd_bs"
  [ -n "${__dd_count:+isset}" ] && _test_parse_int "$__dd_count"
  [ -n "${__dd_skip:+isset}" ]  && _test_parse_int "$__dd_skip"
  [ -n "${__dd_seek:+isset}" ]  && _test_parse_int "$__dd_seek"
  # Normalize list options (item[,...]) to remove duplicates and null items (,,[,...])
  if [ -n "${__dd_conv:+isset}" ]; then
     __dd_conv="$(_dd_listnorm "$__dd_conv")"
  fi
  if [ -n "${__dd_iflag:+isset}" ]; then
    __dd_iflag="$(_dd_listnorm "$__dd_iflag")"
    if _dd_listhas "$__dd_iflag" fullblock && [ $DD_IFLAG_FULLBLOCK -ne 1 ]; then
      __dd_emu_fullblock=1
      __dd_iflag="$(_dd_listrem "$__dd_iflag" fullblock)"
    fi
    if _dd_listhas "$__dd_iflag" skip_bytes && [ $DD_IFLAG_SKIPBYTES -ne 1 ]; then
      __dd_emu_skipbytes=1
      __dd_iflag="$(_dd_listrem "$__dd_iflag" skip_bytes)"
    fi
    if _dd_listhas "$__dd_iflag" count_bytes && [ $DD_IFLAG_COUNTBYTES -ne 1 ]; then
      __dd_emu_countbytes=1
      __dd_iflag="$(_dd_listrem "$__dd_iflag" count_bytes)"
    fi
  fi
  if [ -n "${__dd_oflag:+isset}" ]; then
     __dd_oflag="$(_dd_listnorm "$__dd_oflag")"
  fi

  if [ $__dd_emu_fullblock -eq 1 ]; then
    # Notes about dd's buffering/blocking behavior:
    # * For GNU dd bs= always takes precedence over ibs= and obs=; for BusyBox (and others?) it's positional
    #   We should adhere to the GNU standard as it's easier to implement and this func is essentially a shim for GNU dd
    # * Unless bs= or obs= is set dd will write what its read call returned (up to ibs bytes)
    # * If ibs > obs dd will write up to ibs bytes per read regardless of obs! (can this be modified with a conv= option?)
    # * Because count= and skip= *limit* INPUT BLOCKS which can ALWAYS be PARTIAL READS/SKIPS the only way to ensure
    #   an arbitrary number of bytes/ibs-sized blocks are skipped/written out is to use iflag=fullblock or buffer dd with another
    #   by matching obs of first to ibs of second (as first dd will block until either a full output block (of obs= or bs= size)
    #   is ready to write, or EOF from input)
    # We need to place a buffer of a known size between the input and output using another instance of dd
    # Never set bs= on the first dd!
    # cbs=, *conv=, skip=, count=, ibs=, if=, and iflag= apply to first
    # *conv=, seek=, obs=, of=, and oflag= apply to second
    # ibs=1M bs=3M count=2
    # TODO:
    # What to set block size to if unset as we need to sync on a value? Probably set to 512, to be safe unless
    # there's an easy, portable way to check _POSIX_PIPE_BUF or PIPE_BUF from limits.h
    # Emulate skip_bytes and count_bytes -- if dd ! has skip_bytes or count_bytes then run in a loop
    _errecho "WARNING: Emulating GNU dd iflag=fullblock"
    __dd_a=
    if [ -n "${__dd_conv:+isset}" ]; then
      # Remove conv= options that apply to the output blocks and file, then add them to a seperate list for second dd
      for __dd_a in excl nocreat notrunc fdatasync fsync; do
        _dd_listhas "$__dd_conv" $__dd_a || continue
        __dd_conv="$(_dd_listrem "$__dd_conv" $__dd_a)"
        __dd_bufd_conv="$(_dd_listadd "${__dd_bufd_conv-}" $__dd_a)"
      done
    fi
    __dd_def_bs=512
    while : ; do
      # NOTE: BusyBox dd will write a partial output block if ibs is equal to obs, therefore we set first dd ibs=obs+1
      { __dd_stats="$( \
          dd status=none ibs="$((${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}} + 1))" obs="${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}}" \
            ${__dd_cbs:+cbs="$__dd_cbs"} ${__dd_conv:+conv="$__dd_conv"} \
            ${__dd_if:+if="$__dd_if"} ${__dd_iflag:+iflag="$__dd_iflag"} \
          | 2>&1 1>&3 dd ibs="${__dd_bs:-${__dd_ibs:-${__dd_def_bs}}}" obs="${__dd_bs:-${__dd_obs:-${__dd_def_bs}}}" \
            ${__dd_count:+count="$__dd_count"} ${__dd_skip:+skip="$__dd_skip"} ${__dd_seek:+seek="$__dd_seek"} \
            ${__dd_of:+of="$__dd_of"} ${__dd_oflag:+oflag="$__dd_oflag"} ${__dd_bufd_conv:+conv="$__dd_bufd_conv"} \
        )";
      } 3>&1
      _errecho ">>>$__dd_stats"
      exit

      # TODO Get all of stderr from dd (remove grep) and case through each line with globs, this would make for more
      # resilient parsing as well as allowing for error checking
      [ -n "$__dd_stats" ] || _ERR 'Failed to parse dd status output'
      __dd_stats_in="${__dd_stats%% records in"$NL"*}"
      __dd_stats_out="${__dd_stats##"${__dd_stats%%"$NL"*}$NL"}"
      __dd_stats_out="${__dd_stats_out% records out}"
      [ ${#__dd_stats_in} -eq 3 ]  && [ -z "${__dd_stats_in#?+?}" ]  || _ERR 'Failed to parse dd records in'
      [ ${#__dd_stats_out} -eq 3 ] && [ -z "${__dd_stats_out#?+?}" ] || _ERR 'Failed to parse dd records out'
      __dd_stats_out_whole="${__dd_stats_out%+*}"
      __dd_stats_out_partial="${__dd_stats_out#*+}"
      __dd_stats_in_whole="${__dd_stats_out%+*}"
      __dd_stats_in_partial="${__dd_stats_in#*+}"
      _errecho "IN:  $(($__dd_stats_in_whole * $__dd_bs)) + (${__dd_stats_in_partial} * ?)"
      _errecho "OUT: $(($__dd_stats_out_whole * $__dd_bs)) + (${__dd_stats_out_partial} * ?)"
      break # TODO REMOVE --------------------------------********************************************
    done
  else
    _errecho 'Using GNU dd'
    _errecho "dd ${__dd_bs:+bs="$__dd_bs"} ${__dd_cbs:+cbs="$__dd_cbs"} ${__dd_conv:+conv="$__dd_conv"}
          ${__dd_count:+count="$__dd_count"} ${__dd_skip:+skip="$__dd_skip"} ${__dd_seek:+seek="$__dd_seek"}
          ${__dd_ibs:+ibs="$__dd_ibs"} ${__dd_if:+if="$__dd_if"} ${__dd_iflag:+iflag="$__dd_iflag"}
          ${__dd_ibs:+obs="$__dd_obs"} ${__dd_of:+of="$__dd_of"} ${__dd_oflag:+oflag="$__dd_oflag"}"
    { __dd_stats="$( \
        2>&1 1>&3 dd ${__dd_bs:+bs="$__dd_bs"} ${__dd_cbs:+cbs="$__dd_cbs"} ${__dd_conv:+conv="$__dd_conv"} \
          ${__dd_count:+count="$__dd_count"} ${__dd_skip:+skip="$__dd_skip"} ${__dd_seek:+seek="$__dd_seek"} \
          ${__dd_ibs:+ibs="$__dd_ibs"} ${__dd_if:+if="$__dd_if"} ${__dd_iflag:+iflag="$__dd_iflag"} \
          ${__dd_ibs:+obs="$__dd_obs"} ${__dd_of:+of="$__dd_of"} ${__dd_oflag:+oflag="$__dd_oflag"} \
      )";
    } 3>&1
  fi
}

_test_source() {
  # Verifies the beginning and end of the stream
  __tstsrc_total_bytes=$(($2 + 0))
  __SENDSTREAM__subvolname=
  _reconstruct_source "$1" "$2" "$3" $((1024 * 1024)) 0 | {
    # NOTE: The send stream stores number values as little-endian (0x3c, 0x00 is decimal value 60, not 15360)
    # Thus we can manipulate them as number strings using od and and other tools, as they will terminate reading
    # on the first 0x00 (null) byte
    # See: https://btrfs.wiki.kernel.org/index.php/Design_notes_on_Send/Receive

    # send stream header: 17 bytes
    dd status=none bs=1 count=13 | grep -q ^btrfs-stream         || _ERR "bad magic value" # magic "btrfs-stream\0"
    dd status=none bs=1 count=4  | grep -q ^"$(printf '\001')"\$ || _ERR "stream version != 0x01" # stream version

    # send command header: 10 bytes
    dd status=none bs=1 skip=4 count=0 # command size; unneeded as the only info we want is in TLV1
    # Expect and validate a "Send subvolume or snapshot" command (0x01 or 0x02)
    __tstsrc_cmdtype=$(($(dd status=none bs=1 count=2 | od -An -vtu2) + 0)) # command type
    [ $__tstsrc_cmdtype -eq 1 ] || [ $__tstsrc_cmdtype -eq 2 ] || _ERR "command type != 0x01|0x02 "
    # NOTE: We don't perform a CRC32 check here as we have no easy way of getting the bytes to checksum (they contain 0x0 anyway!)
    dd status=none bs=1 skip=4 count=0 # CRC32

    # send TLV1 (name) header: 4 bytes
    dd status=none bs=1 count=2 | grep -q ^"$(printf '\017')"\$ || _ERR "TLV1 type != 0x0f"
    __tstsrc_subvolname_size=$(($(dd status=none bs=1 count=2 | od -An -vtu2) + 0))

    # send TLV1 (name) payload: $subvolname_size bytes
    __SENDSTREAM__subvolname="$(dd status=none bs=1 count=$__tstsrc_subvolname_size)"

    # skip to end - 6 bytes (send end command)
    # TODO? Skip this check altogether and WARN if $__total_bytes is over $4 and fullblock or skip_bytes is unavailable
    dd status=none bs=1M iflag=fullblock,skip_bytes skip=$(($__tstsrc_total_bytes - 6 - $__tstsrc_subvolname_size - 31)) count=0
    dd status=none bs=1 count=2 | grep -q ^"$(printf '\025')"\$ || _ERR "send end fail"
    dd status=none bs=1 count=4 | grep -q ^"$(printf '\120\154\311\235')"\$ || _ERR "send end fail"
  }
  unset __tstsrc_total_bytes __tstsrc_subvolname_size __tstsrc_cmdtype
}

_reconstruct_source() {
  __source_list="$1"
  __total_bytes=$(($2 + 0))
  __toolchain="${3-}"
  __block_size=$((${4:-BLOCKSIZE} + 0))
  __source_destroy="${5:-0}"

  # TODO Does this belong here or below in main? (Prob. the latter)
  if [ "$INPLACE" -eq 1 ]; then
    # TODO ASK FOR CONFIRMATION!
    _errecho "WARNING: Disabling SIGINT (Ctrl-c) for destructive operation!"
    trap - INT
  fi

  __read_bytes=0
  __remaining_bytes="$__total_bytes"
  for __f in $__source_list; do
    __f_size="$(stat -c%s "$__f")"
    __f_remaining_bytes="$__f_size"
    __f_pos=0
    __dd_bytes="$__block_size"
    while : ; do
      [ $__remaining_bytes -gt 0 ] || break
      [ $__f_remaining_bytes -gt 0 ] || break

      [ $__dd_bytes -le $__remaining_bytes ] || __dd_bytes=$__remaining_bytes
      [ $__dd_bytes -le $__f_remaining_bytes ] || __dd_bytes=$__f_remaining_bytes


      # TODO? Use dd without unportable options and WARN if fullblock, skip_bytes, or count_bytes is unavailable
      # This would require parsing dd's status output to determine the number of bytes read
      # _errecho "Read from: $__rpos"
      dd status=none if="$__f" bs=1M skip="$__f_pos" count="$__dd_bytes" iflag=fullblock,skip_bytes,count_bytes

      __f_pos=$(($__f_pos + $__dd_bytes))
      __f_remaining_bytes=$(($__f_remaining_bytes - $__dd_bytes))
      __read_bytes=$(($__read_bytes + $__dd_bytes))
      __remaining_bytes=$(($__remaining_bytes - $__dd_bytes))

      # TODO fallocate
      # _errecho "fallocate"
      #fallocate --keep-size --punch-hole --offset $readpos --length $readsize $infile >&2 &
    done
    #_errecho "FILE DONE: ${__f}"
  done
  #_errecho "READ DONE"
}

_USAGE() {
  >&2 printf \
'usage: [TESTRUN=1] [BLOCKSIZE=<bytes>] [INPLACE=1] [TRACE=1] %s <info-file> <target-subvol>

Environment variables:

TESTRUN=1  Perform a test run of BLOCKSIZE bytes (disables INPLACE)

BLOCKSIZE=<bytes>  Set the amount of bytes read (and truncated, if INPLACE) at a time
                   Note that shell arithmetic $((...)) can be used to calculate values, for example
                   BLOCKSIZE=$((64 * 1024 * 1024)) sets the value to 67108864 (64MiB), the default

INPLACE=1  Truncate the head of the source raw backup file (fallocate --punch-hole) as its read;
           a mandatory test run will automatically be performed and must complete successfully
           === WARNING ===
           THIS OPTION DESTROYS THE RAW BACKUP SOURCE FILE -- ENSURE THAT YOU HAVE ANOTHER COPY
           OF THE SNAPSHOT OR CAN AFFORD TO LOSE THE DATA BEFORE ENABLING THIS OPTION!
           If the restore operation fails for any reason the file will be PERMANENTLY CORRUPTED,
           so only use if absolutely necessary; e.g. the backup file and target are on the same
           btrfs filesystem and the space used by the file is needed to restore the subvolume

TRACE=1    Enable shell trace output

' "$(basename "${0}")"
  exit 1
}

_ERR() {
  _errecho "ERROR: ${1}"
  [ "${2:-0}" -eq 1 ] && { _errecho; USAGE; }
  exit "${3:-1}"
}

_DEPENDENCY_ERR() {
  >&2 printf 'ERROR: "%s" not found in $PATH%s\n' "$1" "${2:+"; is the \"${2}\" package (or equivalent) installed?"}"
  exit 9
}

_CLEANUP() ( # VAR PREFIX: __clnup_
  set +e
  __clnup_l="${__clnup_paths-}"; while [ "$__clnup_l" != "${__clnup_l2-}" ]; do
    __clnup_l="${__clnup_l2:-${__clnup_l}}"
    __clnup_l2="${__clnup_l%${__file_path_sep}*}"
    __clnup_v="${__clnup_l#${__clnup_l2}${__file_path_sep}}"
    rm "$__clnup_v"
  done; unset __clnup_l __clnup_l2 __clnup_v
)

_SHUTDOWN() {
  [ "${__shutdown_bypass-0}" -eq 1 ] && return
  __shutdown_bypass=1
  case "${1-}" in
    INT|TERM) trap - INT TERM;;
    EXIT) : ;;
    *) _ERR "Invalid shutdown signal: $1" 0 127
  esac
  _echo "==> SHUTDOWN: $1"
  _CLEANUP
}

_MAIN() {
  _trap _SHUTDOWN INT TERM EXIT

  # Required dependencies
  _require_bin awk      awk
  _require_bin grep     grep
  _require_bin sed      sed # TODO Replace all sed with awk
  _require_bin btrfs    btrfs-progs
  _require_bin basename coreutils
  _require_bin dirname  coreutils
  _require_bin dd       coreutils
  _require_bin od       coreutils
  _require_bin readlink coreutils
  _require_bin stat     coreutils

  # Feature-test dd
  DD_IFLAG_FULLBLOCK=0
  DD_IFLAG_SKIPBYTES=0
  DD_IFLAG_COUNTBYTES=0
  dd_helptxt="$(dd --help 2>&1)" \
  || dd_helptxt="$(dd -h 2>&1)" \
  || _ERR "Failed to parse help text for dd"
  _str_contains "$dd_helptxt" fullblock   && DD_IFLAG_FULLBLOCK=1
  _str_contains "$dd_helptxt" skip_bytes  && DD_IFLAG_SKIPBYTES=1
  _str_contains "$dd_helptxt" count_bytes && DD_IFLAG_COUNTBYTES=1

  if [ "$INPLACE" -eq 1 ]; then
    _require_bin fallocate  util-linux
    _require_bin findmnt    util-linux

    # Feature-test fallocate
    falloc_punch_hole=
    falloc_helptxt="$(fallocate --help 2>&1)" \
    || falloc_helptxt="$(fallocate -h 2>&1)" \
    || _ERR "Failed to parse help text for fallocate"
    _str_contains "$falloc_helptxt" --punch-hole && falloc_punch_hole=' --punch-hole'

    # TODO Feature-test findmnt
  fi

total=$((1024 * 1024 * 1024 + 124283))
#dd status=none ibs=3 obs=7 if=/dev/random
set +x
DD_BLOCKFACTOR=1
DD_IFLAG_FULLBLOCK=1
_dd if=/dev/random iflag=fullblock bs=$((1 * KiB)) count=2 | pv -bn >/dev/null
exit

  # Script arguments
  source_info="${1-}"
  target="${2-}"

  # Source check
  if [ -z "$source_info" ]; then
    _ERR "Info (sidecar) file was not specified" 1
  elif ! [ -r "$source_info" ]; then
    _ERR "Info (sidecar) file doesn't exist or isn't readable: ${source_info}"
  fi

  source_dir="$(dirname "$(readlink -f "$source_info")")"
  source_info="${source_dir}/${source_info##*/}" # Canonicalize
  _load_info_file "$source_info"
  source_name="${__INFOFILE__FILE##*/}"
  subvol_name="${source_name%.btrfs*}"
  source="${source_dir}/${source_name}"

  if [ "${__INFOFILE__INCOMPLETE-0}" -eq 1 ]; then
    _ERR "Raw backup file is marked incomplete"
  fi

  if [ -n "${__INFOFILE__split+x}" ]; then
    source_glob="${source}.split_*"
  fi

  file_list=${source_glob:-$source}

  # Source sanity checks and preliminary info gathering
  toolchain=
  total_size=0
  for f in $file_list; do
    # Attempt capturing the filesystem name which houses the source file(s) to test for fallocate --punch-hole compat
    [ "$INPLACE" -eq 1 ] && "${source_fs:="$(findmnt -n -o FSTYPE --target "$f")"}"
    [ -r "$f" ] || _ERR "File doesn't exist or isn't readable: ${f}"
    fsize="$(stat -c%s "$f")"
    [ "$fsize" -gt 0 ] || _ERR "Source file appears empty (stat reported 0 bytes or errored): ${f}"
    total_size=$(($total_size + $fsize))
  done

  # $do_test_source && ...
  _test_source "$file_list" $total_size "$toolchain" || _ERR "Source test failed"

  _echo "NAME FROM STREAM: $__SENDSTREAM__subvolname" # Wait, what?
  [ -n "${__SENDSTREAM__subvolname-}" ] && subvolname="$__SENDSTREAM__subvolname"

  # Target sanity checks
  if [ -e "${target}/${subvol_name}" ]; then
    _ERR "Restore target exists, aborting: ${target}/${subvol_name}"
  fi

  set +e; target_info="$(btrfs subvolume show "$target")"; set -e
  [ $? -eq 0 ] || target_info=

  if [ -z "$target_info" ]; then
    _ERR "Restore target does not appear to be a btrfs subvolume (\"btrfs sub show '${target}'\" failed)"
  fi

  if printf '%s' "$target_info" | grep Flags: | grep -q readonly; then
    _ERR "Restore target appears to be readonly: ${target}"
  fi

  # Main
  _reconstruct_source "$file_list" $total_size "$toolchain" "$BLOCKSIZE" 0 \
  | btrfs receive -v "$target" #; _echo ">>>${?}" # "$target"

  exit 0
}

_MAIN "$@"

##### TODO
# * Build $toolchain pipeline string and eval it safely in _reconstruct_source
# * TESTRUN: make sure key can decrypt, or passphrase is correct, all utilities work, etc before INPLACE destructive read
# * ? unencrypt
#   - openssl
#     - keyfile
#     - kdf
#   - gpg
# * ? uncompress
#   - xz
#   - gzip
